<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Spring Cloud Netflix</title><link rel="stylesheet" type="text/css" href="css/manual-singlepage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div lang="en" class="book"><div class="titlepage"><div><div><h1 class="title"><a name="d0e3"></a>Spring Cloud Netflix</h1></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="preface"><a href="#d0e9"></a></span></dt><dt><span class="chapter"><a href="#_service_discovery_eureka_clients">1. Service Discovery: Eureka Clients</a></span></dt><dd><dl><dt><span class="section"><a href="#netflix-eureka-client-starter">1.1. How to Include Eureka Client</a></span></dt><dt><span class="section"><a href="#_registering_with_eureka">1.2. Registering with Eureka</a></span></dt><dt><span class="section"><a href="#_authenticating_with_the_eureka_server">1.3. Authenticating with the Eureka Server</a></span></dt><dt><span class="section"><a href="#_status_page_and_health_indicator">1.4. Status Page and Health Indicator</a></span></dt><dt><span class="section"><a href="#_registering_a_secure_application">1.5. Registering a Secure Application</a></span></dt><dt><span class="section"><a href="#_eureka_s_health_checks">1.6. Eureka&#8217;s Health Checks</a></span></dt><dt><span class="section"><a href="#_eureka_metadata_for_instances_and_clients">1.7. Eureka Metadata for Instances and Clients</a></span></dt><dd><dl><dt><span class="section"><a href="#_using_eureka_on_cloudfoundry">1.7.1. Using Eureka on Cloudfoundry</a></span></dt><dt><span class="section"><a href="#_using_eureka_on_aws">1.7.2. Using Eureka on AWS</a></span></dt><dt><span class="section"><a href="#_changing_the_eureka_instance_id">1.7.3. Changing the Eureka Instance ID</a></span></dt></dl></dd><dt><span class="section"><a href="#_using_the_eurekaclient">1.8. Using the EurekaClient</a></span></dt><dt><span class="section"><a href="#_alternatives_to_the_native_netflix_eurekaclient">1.9. Alternatives to the native Netflix EurekaClient</a></span></dt><dt><span class="section"><a href="#_why_is_it_so_slow_to_register_a_service">1.10. Why is it so Slow to Register a Service?</a></span></dt><dt><span class="section"><a href="#_zones">1.11. Zones</a></span></dt></dl></dd><dt><span class="chapter"><a href="#spring-cloud-eureka-server">2. Service Discovery: Eureka Server</a></span></dt><dd><dl><dt><span class="section"><a href="#netflix-eureka-server-starter">2.1. How to Include Eureka Server</a></span></dt><dt><span class="section"><a href="#spring-cloud-running-eureka-server">2.2. How to Run a Eureka Server</a></span></dt><dt><span class="section"><a href="#spring-cloud-eureka-server-zones-and-regions">2.3. High Availability, Zones and Regions</a></span></dt><dt><span class="section"><a href="#_standalone_mode">2.4. Standalone Mode</a></span></dt><dt><span class="section"><a href="#_peer_awareness">2.5. Peer Awareness</a></span></dt><dt><span class="section"><a href="#_prefer_ip_address">2.6. Prefer IP Address</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_circuit_breaker_hystrix_clients">3. Circuit Breaker: Hystrix Clients</a></span></dt><dd><dl><dt><span class="section"><a href="#netflix-hystrix-starter">3.1. How to Include Hystrix</a></span></dt><dt><span class="section"><a href="#_propagating_the_security_context_or_using_spring_scopes">3.2. Propagating the Security Context or using Spring Scopes</a></span></dt><dt><span class="section"><a href="#_health_indicator">3.3. Health Indicator</a></span></dt><dt><span class="section"><a href="#_hystrix_metrics_stream">3.4. Hystrix Metrics Stream</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_circuit_breaker_hystrix_dashboard">4. Circuit Breaker: Hystrix Dashboard</a></span></dt><dt><span class="chapter"><a href="#_hystrix_timeouts_and_ribbon_clients">5. Hystrix Timeouts And Ribbon Clients</a></span></dt><dd><dl><dt><span class="section"><a href="#netflix-hystrix-dashboard-starter">5.1. How to Include Hystrix Dashboard</a></span></dt><dt><span class="section"><a href="#_turbine">5.2. Turbine</a></span></dt><dt><span class="section"><a href="#_turbine_stream">5.3. Turbine Stream</a></span></dt></dl></dd><dt><span class="chapter"><a href="#spring-cloud-ribbon">6. Client Side Load Balancer: Ribbon</a></span></dt><dd><dl><dt><span class="section"><a href="#netflix-ribbon-starter">6.1. How to Include Ribbon</a></span></dt><dt><span class="section"><a href="#_customizing_the_ribbon_client">6.2. Customizing the Ribbon Client</a></span></dt><dt><span class="section"><a href="#_customizing_the_ribbon_client_using_properties">6.3. Customizing the Ribbon Client using properties</a></span></dt><dt><span class="section"><a href="#_using_ribbon_with_eureka">6.4. Using Ribbon with Eureka</a></span></dt><dt><span class="section"><a href="#spring-cloud-ribbon-without-eureka">6.5. Example: How to Use Ribbon Without Eureka</a></span></dt><dt><span class="section"><a href="#_example_disable_eureka_use_in_ribbon">6.6. Example: Disable Eureka use in Ribbon</a></span></dt><dt><span class="section"><a href="#_using_the_ribbon_api_directly">6.7. Using the Ribbon API Directly</a></span></dt><dt><span class="section"><a href="#ribbon-child-context-eager-load">6.8. Caching of Ribbon Configuration</a></span></dt></dl></dd><dt><span class="chapter"><a href="#spring-cloud-feign">7. Declarative REST Client: Feign</a></span></dt><dd><dl><dt><span class="section"><a href="#netflix-feign-starter">7.1. How to Include Feign</a></span></dt><dt><span class="section"><a href="#spring-cloud-feign-overriding-defaults">7.2. Overriding Feign Defaults</a></span></dt><dt><span class="section"><a href="#_creating_feign_clients_manually">7.3. Creating Feign Clients Manually</a></span></dt><dt><span class="section"><a href="#spring-cloud-feign-hystrix">7.4. Feign Hystrix Support</a></span></dt><dt><span class="section"><a href="#spring-cloud-feign-hystrix-fallback">7.5. Feign Hystrix Fallbacks</a></span></dt><dt><span class="section"><a href="#_feign_and_literal_primary_literal">7.6. Feign and <code class="literal">@Primary</code></a></span></dt><dt><span class="section"><a href="#spring-cloud-feign-inheritance">7.7. Feign Inheritance Support</a></span></dt><dt><span class="section"><a href="#_feign_request_response_compression">7.8. Feign request/response compression</a></span></dt><dt><span class="section"><a href="#_feign_logging">7.9. Feign logging</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_external_configuration_archaius">8. External Configuration: Archaius</a></span></dt><dt><span class="chapter"><a href="#_router_and_filter_zuul">9. Router and Filter: Zuul</a></span></dt><dd><dl><dt><span class="section"><a href="#netflix-zuul-starter">9.1. How to Include Zuul</a></span></dt><dt><span class="section"><a href="#netflix-zuul-reverse-proxy">9.2. Embedded Zuul Reverse Proxy</a></span></dt><dt><span class="section"><a href="#_zuul_http_client">9.3. Zuul Http Client</a></span></dt><dt><span class="section"><a href="#_cookies_and_sensitive_headers">9.4. Cookies and Sensitive Headers</a></span></dt><dt><span class="section"><a href="#_ignored_headers">9.5. Ignored Headers</a></span></dt><dt><span class="section"><a href="#_the_routes_endpoint">9.6. The Routes Endpoint</a></span></dt><dt><span class="section"><a href="#_strangulation_patterns_and_local_forwards">9.7. Strangulation Patterns and Local Forwards</a></span></dt><dt><span class="section"><a href="#_uploading_files_through_zuul">9.8. Uploading Files through Zuul</a></span></dt><dt><span class="section"><a href="#_query_string_encoding">9.9. Query String Encoding</a></span></dt><dt><span class="section"><a href="#_plain_embedded_zuul">9.10. Plain Embedded Zuul</a></span></dt><dt><span class="section"><a href="#_disable_zuul_filters">9.11. Disable Zuul Filters</a></span></dt><dt><span class="section"><a href="#hystrix-fallbacks-for-routes">9.12. Providing Hystrix Fallbacks For Routes</a></span></dt><dt><span class="section"><a href="#zuul-developer-guide">9.13. Zuul Developer Guide</a></span></dt><dd><dl><dt><span class="section"><a href="#_the_zuul_servlet">9.13.1. The Zuul Servlet</a></span></dt><dt><span class="section"><a href="#_zuul_requestcontext">9.13.2. Zuul RequestContext</a></span></dt><dt><span class="section"><a href="#__literal_enablezuulproxy_literal_vs_literal_enablezuulserver_literal">9.13.3. <code class="literal">@EnableZuulProxy</code> vs. <code class="literal">@EnableZuulServer</code></a></span></dt><dt><span class="section"><a href="#__literal_enablezuulserver_literal_filters">9.13.4. <code class="literal">@EnableZuulServer</code> Filters</a></span></dt><dt><span class="section"><a href="#__literal_enablezuulproxy_literal_filters">9.13.5. <code class="literal">@EnableZuulProxy</code> Filters</a></span></dt><dt><span class="section"><a href="#_custom_zuul_filter_examples">9.13.6. Custom Zuul Filter examples</a></span></dt><dt><span class="section"><a href="#_how_to_write_a_pre_filter">9.13.7. How to Write a Pre Filter</a></span></dt><dt><span class="section"><a href="#_how_to_write_a_route_filter">9.13.8. How to Write a Route Filter</a></span></dt><dt><span class="section"><a href="#_how_to_write_a_post_filter">9.13.9. How to Write a Post Filter</a></span></dt><dt><span class="section"><a href="#_how_zuul_errors_work">9.13.10. How Zuul Errors Work</a></span></dt><dt><span class="section"><a href="#_zuul_eager_application_context_loading">9.13.11. Zuul Eager Application Context Loading</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#_polyglot_support_with_sidecar">10. Polyglot support with Sidecar</a></span></dt><dt><span class="chapter"><a href="#netflix-rxjava-springmvc">11. RxJava with Spring MVC</a></span></dt><dt><span class="chapter"><a href="#netflix-metrics">12. Metrics: Spectator, Servo, and Atlas</a></span></dt><dd><dl><dt><span class="section"><a href="#_dimensional_vs_hierarchical_metrics">12.1. Dimensional vs. Hierarchical Metrics</a></span></dt><dt><span class="section"><a href="#_default_metrics_collection">12.2. Default Metrics Collection</a></span></dt><dt><span class="section"><a href="#netflix-metrics-spectator">12.3. Metrics Collection: Spectator</a></span></dt><dd><dl><dt><span class="section"><a href="#_spectator_counter">12.3.1. Spectator Counter</a></span></dt><dt><span class="section"><a href="#_spectator_timer">12.3.2. Spectator Timer</a></span></dt><dt><span class="section"><a href="#_spectator_gauge">12.3.3. Spectator Gauge</a></span></dt><dt><span class="section"><a href="#_spectator_distribution_summaries">12.3.4. Spectator Distribution Summaries</a></span></dt></dl></dd><dt><span class="section"><a href="#netflix-metrics-servo">12.4. Metrics Collection: Servo</a></span></dt><dd><dl><dt><span class="section"><a href="#_creating_servo_monitors">12.4.1. Creating Servo Monitors</a></span></dt></dl></dd><dt><span class="section"><a href="#netflix-metrics-atlas">12.5. Metrics Backend: Atlas</a></span></dt><dd><dl><dt><span class="section"><a href="#_global_tags">12.5.1. Global tags</a></span></dt><dt><span class="section"><a href="#_using_atlas">12.5.2. Using Atlas</a></span></dt></dl></dd><dt><span class="section"><a href="#retrying-failed-requests">12.6. Retrying Failed Requests</a></span></dt><dd><dl><dt><span class="section"><a href="#_configuration">12.6.1. Configuration</a></span></dt><dt><span class="section"><a href="#_zuul">12.6.2. Zuul</a></span></dt></dl></dd></dl></dd></dl></div><div class="preface"><div class="titlepage"><div><div><h1 class="title"><a name="d0e9" href="#d0e9"></a></h1></div></div></div><p><span class="strong"><strong>1.3.7.BUILD-SNAPSHOT</strong></span></p><p>This project provides Netflix OSS integrations for Spring Boot apps through autoconfiguration
and binding to the Spring Environment and other Spring programming model idioms. With a few
simple annotations you can quickly enable and configure the common patterns inside your
application and build large distributed systems with battle-tested Netflix components. The
patterns provided include Service Discovery (Eureka), Circuit Breaker (Hystrix),
Intelligent Routing (Zuul) and Client Side Load Balancing (Ribbon).</p></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="_service_discovery_eureka_clients" href="#_service_discovery_eureka_clients"></a>1.&nbsp;Service Discovery: Eureka Clients</h1></div></div></div><p>Service Discovery is one of the key tenets of a microservice based architecture. Trying to hand configure each client or some form of convention can be very difficult to do and can be very brittle.  Eureka is the Netflix Service Discovery Server and Client.  The server can be configured and deployed to be highly available, with each server replicating state about the registered services to the others.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="netflix-eureka-client-starter" href="#netflix-eureka-client-starter"></a>1.1&nbsp;How to Include Eureka Client</h2></div></div></div><p>To include Eureka Client in your project use the starter with group <code class="literal">org.springframework.cloud</code>
and artifact id <code class="literal">spring-cloud-starter-eureka</code>. See the <a class="link" href="https://projects.spring.io/spring-cloud/" target="_top">Spring Cloud Project page</a>
for details on setting up your build system with the current Spring Cloud Release Train.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_registering_with_eureka" href="#_registering_with_eureka"></a>1.2&nbsp;Registering with Eureka</h2></div></div></div><p>When a client registers with Eureka, it provides meta-data about itself
such as host and port, health indicator URL, home page etc.  Eureka
receives heartbeat messages from each instance belonging to a service.
If the heartbeat fails over a configurable timetable, the instance is
normally removed from the registry.</p><p>Example eureka client:</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<em><span class="hl-annotation" style="color: gray">@ComponentScan</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableAutoConfiguration</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableEurekaClient</span></em>
<em><span class="hl-annotation" style="color: gray">@RestController</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Application {

    <em><span class="hl-annotation" style="color: gray">@RequestMapping("/")</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String home() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Hello world"</span>;
    }

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(String[] args) {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> SpringApplicationBuilder(Application.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>).web(true).run(args);
    }

}</pre><p>(i.e. utterly normal Spring Boot app). In this example we use
<code class="literal">@EnableEurekaClient</code> explicitly, but with only Eureka available you
could also use <code class="literal">@EnableDiscoveryClient</code>. Configuration is required to
locate the Eureka server. Example:</p><p><b>application.yml.&nbsp;</b>
</p><pre class="screen">eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/</pre><p>
</p><p>where "defaultZone" is a magic string fallback value that provides the
service URL for any client that doesn&#8217;t express a preference
(i.e. it&#8217;s a useful default).</p><p>The default application name (service ID), virtual host and non-secure
port, taken from the <code class="literal">Environment</code>, are <code class="literal">${spring.application.name}</code>,
<code class="literal">${spring.application.name}</code> and <code class="literal">${server.port}</code> respectively.</p><p><code class="literal">@EnableEurekaClient</code> makes the app into both a Eureka "instance"
(i.e. it registers itself) and a "client" (i.e. it can query the
registry to locate other services). The instance behaviour is driven
by <code class="literal">eureka.instance.*</code> configuration keys, but the defaults will be
fine if you ensure that your application has a
<code class="literal">spring.application.name</code> (this is the default for the Eureka service
ID, or VIP).</p><p>See <a class="link" href="https://github.com/spring-cloud/spring-cloud-netflix/tree/master/spring-cloud-netflix-eureka-client/src/main/java/org/springframework/cloud/netflix/eureka/EurekaInstanceConfigBean.java" target="_top">EurekaInstanceConfigBean</a> and <a class="link" href="https://github.com/spring-cloud/spring-cloud-netflix/tree/master/spring-cloud-netflix-eureka-client/src/main/java/org/springframework/cloud/netflix/eureka/EurekaClientConfigBean.java" target="_top">EurekaClientConfigBean</a> for more details of the configurable options.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_authenticating_with_the_eureka_server" href="#_authenticating_with_the_eureka_server"></a>1.3&nbsp;Authenticating with the Eureka Server</h2></div></div></div><p>HTTP basic authentication will be automatically added to your eureka
client if one of the <code class="literal">eureka.client.serviceUrl.defaultZone</code> URLs has
credentials embedded in it (curl style, like
<code class="literal"><a class="link" href="http://user:password@localhost:8761/eureka" target="_top">http://user:password@localhost:8761/eureka</a></code>). For more complex needs
you can create a <code class="literal">@Bean</code> of type <code class="literal">DiscoveryClientOptionalArgs</code> and
inject <code class="literal">ClientFilter</code> instances into it, all of which will be applied
to the calls from the client to the server.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Because of a limitation in Eureka it isn&#8217;t possible to support
per-server basic auth credentials, so only the first set that are
found will be used.</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_status_page_and_health_indicator" href="#_status_page_and_health_indicator"></a>1.4&nbsp;Status Page and Health Indicator</h2></div></div></div><p>The status page and health indicators for a Eureka instance default to
"/info" and "/health" respectively, which are the default locations of
useful endpoints in a Spring Boot Actuator application. You need to
change these, even for an Actuator application if you use a
non-default context path or servlet path
(e.g. <code class="literal">server.servletPath=/foo</code>) or management endpoint path
(e.g. <code class="literal">management.contextPath=/admin</code>). Example:</p><p><b>application.yml.&nbsp;</b>
</p><pre class="screen">eureka:
  instance:
    statusPageUrlPath: ${management.context-path}/info
    healthCheckUrlPath: ${management.context-path}/health</pre><p>
</p><p>These links show up in the metadata that is consumed by clients, and
used in some scenarios to decide whether to send requests to your
application, so it&#8217;s helpful if they are accurate.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_registering_a_secure_application" href="#_registering_a_secure_application"></a>1.5&nbsp;Registering a Secure Application</h2></div></div></div><p>If your app wants to be contacted over HTTPS you can set two flags in
the <code class="literal">EurekaInstanceConfig</code>, <span class="emphasis"><em>viz</em></span>
<code class="literal">eureka.instance.[nonSecurePortEnabled,securePortEnabled]=[false,true]</code>
respectively. This will make Eureka publish instance information
showing an explicit preference for secure communication. The Spring
Cloud <code class="literal">DiscoveryClient</code> will always return a URI starting with <code class="literal">https</code> for a
service configured this way, and the Eureka (native) instance
information will have a secure health check URL.</p><p>Because of the way
Eureka works internally, it will still publish a non-secure URL for
status and home page unless you also override those explicitly.
You can use placeholders to configure the eureka instance urls,
e.g.</p><p><b>application.yml.&nbsp;</b>
</p><pre class="screen">eureka:
  instance:
    statusPageUrl: https://${eureka.hostname}/info
    healthCheckUrl: https://${eureka.hostname}/health
    homePageUrl: https://${eureka.hostname}/</pre><p>
</p><p>(Note that <code class="literal">${eureka.hostname}</code> is a native placeholder only available
in later versions of Eureka. You could achieve the same thing with
Spring placeholders as well, e.g. using <code class="literal">${eureka.instance.hostName}</code>.)</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>If your app is running behind a proxy, and the SSL termination
is in the proxy (e.g. if you run in Cloud Foundry or other platforms
as a service) then you will need to ensure that the proxy "forwarded"
headers are intercepted and handled by the application. An embedded
Tomcat container in a Spring Boot app does this automatically if it
has explicit configuration for the 'X-Forwarded-\*` headers. A sign
that you got this wrong will be that the links rendered by your app to
itself will be wrong (the wrong host, port or protocol).</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_eureka_s_health_checks" href="#_eureka_s_health_checks"></a>1.6&nbsp;Eureka&#8217;s Health Checks</h2></div></div></div><p>By default, Eureka uses the client heartbeat to determine if a client is up.
Unless specified otherwise the Discovery Client will not propagate the
current health check status of the application per the Spring Boot Actuator.  Which means
that after successful registration Eureka will always announce that the
application is in 'UP' state. This behaviour can be altered by enabling
Eureka health checks, which results in propagating application status
to Eureka. As a consequence every other application won&#8217;t be sending
traffic to application in state other then 'UP'.</p><p><b>application.yml.&nbsp;</b>
</p><pre class="screen">eureka:
  client:
    healthcheck:
      enabled: true</pre><p>
</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="images/warning.png"></td><th align="left">Warning</th></tr><tr><td align="left" valign="top"><p><code class="literal">eureka.client.healthcheck.enabled=true</code> should only be set in <code class="literal">application.yml</code>. Setting the value in <code class="literal">bootstrap.yml</code> will cause undesirable side effects like registering in eureka with an <code class="literal">UNKNOWN</code> status.</p></td></tr></table></div><p>If you require more control over the health checks, you may consider
implementing your own <code class="literal">com.netflix.appinfo.HealthCheckHandler</code>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_eureka_metadata_for_instances_and_clients" href="#_eureka_metadata_for_instances_and_clients"></a>1.7&nbsp;Eureka Metadata for Instances and Clients</h2></div></div></div><p>It&#8217;s worth spending a bit of time understanding how the Eureka metadata works, so you can use it in a way that makes sense in your platform. There is standard metadata for things like hostname, IP address, port numbers, status page and health check. These are published in the service registry and used by clients to contact the services in a straightforward way. Additional metadata can be added to the instance registration in the <code class="literal">eureka.instance.metadataMap</code>, and this will be accessible in the remote clients, but in general will not change the behaviour of the client, unless it is made aware of the meaning of the metadata. There are a couple of special cases described below where Spring Cloud already assigns meaning to the metadata map.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_using_eureka_on_cloudfoundry" href="#_using_eureka_on_cloudfoundry"></a>1.7.1&nbsp;Using Eureka on Cloudfoundry</h3></div></div></div><p>Cloudfoundry has a global router so that all instances of the same app have the same hostname (it&#8217;s the same in other PaaS solutions with a similar architecture). This isn&#8217;t necessarily a barrier to using Eureka, but if you use the router (recommended, or even mandatory depending on the way your platform was set up), you need to explicitly set the hostname and port numbers (secure or non-secure) so that they use the router. You might also want to use instance metadata so you can distinguish between the instances on the client (e.g. in a custom load balancer). By default, the <code class="literal">eureka.instance.instanceId</code> is <code class="literal">vcap.application.instance_id</code>. For example:</p><p><b>application.yml.&nbsp;</b>
</p><pre class="screen">eureka:
  instance:
    hostname: ${vcap.application.uris[0]}
    nonSecurePort: 80</pre><p>
</p><p>Depending on the way the security rules are set up in your Cloudfoundry instance, you might be able to register and use the IP address of the host VM for direct service-to-service calls. This feature is not (yet) available on Pivotal Web Services (<a class="link" href="https://run.pivotal.io" target="_top">PWS</a>).</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_using_eureka_on_aws" href="#_using_eureka_on_aws"></a>1.7.2&nbsp;Using Eureka on AWS</h3></div></div></div><p>If the application is planned to be deployed to an AWS cloud, then the Eureka instance will have to be configured to be AWS aware and this can be done by customizing the <a class="link" href="https://github.com/spring-cloud/spring-cloud-netflix/tree/master/spring-cloud-netflix-eureka-client/src/main/java/org/springframework/cloud/netflix/eureka/EurekaInstanceConfigBean.java" target="_top">EurekaInstanceConfigBean</a> the following way:</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<em><span class="hl-annotation" style="color: gray">@Profile("!default")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> EurekaInstanceConfigBean eurekaInstanceConfig(InetUtils inetUtils) {
  EurekaInstanceConfigBean b = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> EurekaInstanceConfigBean(inetUtils);
  AmazonInfo info = AmazonInfo.Builder.newBuilder().autoBuild(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"eureka"</span>);
  b.setDataCenterInfo(info);
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> b;
}</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_changing_the_eureka_instance_id" href="#_changing_the_eureka_instance_id"></a>1.7.3&nbsp;Changing the Eureka Instance ID</h3></div></div></div><p>A vanilla Netflix Eureka instance is registered with an ID that is equal to its host name (i.e. only one service per host). Spring Cloud Eureka provides a sensible default that looks like this: <code class="literal">${spring.cloud.client.hostname}:${spring.application.name}:${spring.application.instance_id:${server.port}}}</code>. For example <code class="literal">myhost:myappname:8080</code>.</p><p>Using Spring Cloud you can override this by providing a unique identifier in <code class="literal">eureka.instance.instanceId</code>. For example:</p><p><b>application.yml.&nbsp;</b>
</p><pre class="screen">eureka:
  instance:
    instanceId: ${spring.application.name}:${vcap.application.instance_id:${spring.application.instance_id:${random.value}}}</pre><p>
</p><p>With this metadata, and multiple service instances deployed on
localhost, the random value will kick in there to make the instance
unique. In Cloudfoundry the <code class="literal">vcap.application.instance_id</code> will be
populated automatically in a Spring Boot application, so the
random value will not be needed.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_using_the_eurekaclient" href="#_using_the_eurekaclient"></a>1.8&nbsp;Using the EurekaClient</h2></div></div></div><p>Once you have an app that is <code class="literal">@EnableDiscoveryClient</code> (or <code class="literal">@EnableEurekaClient</code>) you can use it to
discover service instances from the <a class="link" href="#spring-cloud-eureka-server" title="2.&nbsp;Service Discovery: Eureka Server">Eureka Server</a>. One way to do that is to use the native
<code class="literal">com.netflix.discovery.EurekaClient</code> (as opposed to the Spring
Cloud <code class="literal">DiscoveryClient</code>), e.g.</p><pre class="screen">@Autowired
private EurekaClient discoveryClient;

public String serviceUrl() {
    InstanceInfo instance = discoveryClient.getNextServerFromEureka("STORES", false);
    return instance.getHomePageUrl();
}</pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>Don&#8217;t use the <code class="literal">EurekaClient</code> in <code class="literal">@PostConstruct</code> method or in a
<code class="literal">@Scheduled</code> method (or anywhere where the <code class="literal">ApplicationContext</code> might
not be started yet). It is initialized in a <code class="literal">SmartLifecycle</code> (with
<code class="literal">phase=0</code>) so the earliest you can rely on it being available is in
another <code class="literal">SmartLifecycle</code> with higher phase.</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_alternatives_to_the_native_netflix_eurekaclient" href="#_alternatives_to_the_native_netflix_eurekaclient"></a>1.9&nbsp;Alternatives to the native Netflix EurekaClient</h2></div></div></div><p>You don&#8217;t have to use the raw Netflix <code class="literal">EurekaClient</code> and usually it
is more convenient to use it behind a wrapper of some sort. Spring
Cloud has support for <a class="link" href="#spring-cloud-feign" title="7.&nbsp;Declarative REST Client: Feign">Feign</a> (a REST client
builder) and also <a class="link" href="#spring-cloud-ribbon" title="6.&nbsp;Client Side Load Balancer: Ribbon">Spring <code class="literal">RestTemplate</code></a> using
the logical Eureka service identifiers (VIPs) instead of physical
URLs. To configure Ribbon with a fixed list of physical servers you
can simply set <code class="literal">&lt;client&gt;.ribbon.listOfServers</code> to a comma-separated
list of physical addresses (or hostnames), where <code class="literal">&lt;client&gt;</code> is the ID
of the client.</p><p>You can also use the <code class="literal">org.springframework.cloud.client.discovery.DiscoveryClient</code>
which provides a simple API for discovery clients that is not specific
to Netflix, e.g.</p><pre class="screen">@Autowired
private DiscoveryClient discoveryClient;

public String serviceUrl() {
    List&lt;ServiceInstance&gt; list = discoveryClient.getInstances("STORES");
    if (list != null &amp;&amp; list.size() &gt; 0 ) {
        return list.get(0).getUri();
    }
    return null;
}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_why_is_it_so_slow_to_register_a_service" href="#_why_is_it_so_slow_to_register_a_service"></a>1.10&nbsp;Why is it so Slow to Register a Service?</h2></div></div></div><p>Being an instance also involves a periodic heartbeat to the registry
(via the client&#8217;s <code class="literal">serviceUrl</code>) with default duration 30 seconds. A
service is not available for discovery by clients until the instance,
the server and the client all have the same metadata in their local
cache (so it could take 3 heartbeats). You can change the period using
<code class="literal">eureka.instance.leaseRenewalIntervalInSeconds</code> and this will speed up
the process of getting clients connected to other services. In
production it&#8217;s probably better to stick with the default because
there are some computations internally in the server that make
assumptions about the lease renewal period.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_zones" href="#_zones"></a>1.11&nbsp;Zones</h2></div></div></div><p>If you have deployed Eureka clients to multiple zones than you may prefer that
those clients leverage services within the same zone before trying services
in another zone.  To do this you need to configure your Eureka clients correctly.</p><p>First, you need to make sure you have Eureka servers deployed to each zone and that
they are peers of each other.  See the section on <a class="link" href="#spring-cloud-eureka-server-zones-and-regions" title="2.3&nbsp;High Availability, Zones and Regions">zones and regions</a>
for more information.</p><p>Next you need to tell Eureka which zone your service is in.  You can do this using
the <code class="literal">metadataMap</code> property.  For example if <code class="literal">service 1</code> is deployed to both <code class="literal">zone 1</code>
and <code class="literal">zone 2</code> you would need to set the following Eureka properties in <code class="literal">service 1</code></p><p><span class="strong"><strong>Service 1 in Zone 1</strong></span></p><pre class="screen">eureka.instance.metadataMap.zone = zone1
eureka.client.preferSameZoneEureka = true</pre><p><span class="strong"><strong>Service 1 in Zone 2</strong></span></p><pre class="screen">eureka.instance.metadataMap.zone = zone2
eureka.client.preferSameZoneEureka = true</pre></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="spring-cloud-eureka-server" href="#spring-cloud-eureka-server"></a>2.&nbsp;Service Discovery: Eureka Server</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="netflix-eureka-server-starter" href="#netflix-eureka-server-starter"></a>2.1&nbsp;How to Include Eureka Server</h2></div></div></div><p>To include Eureka Server in your project use the starter with group <code class="literal">org.springframework.cloud</code>
and artifact id <code class="literal">spring-cloud-starter-eureka-server</code>. See the <a class="link" href="https://projects.spring.io/spring-cloud/" target="_top">Spring Cloud Project page</a>
for details on setting up your build system with the current Spring Cloud Release Train.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spring-cloud-running-eureka-server" href="#spring-cloud-running-eureka-server"></a>2.2&nbsp;How to Run a Eureka Server</h2></div></div></div><p>Example eureka server;</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableEurekaServer</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Application {

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(String[] args) {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> SpringApplicationBuilder(Application.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>).web(true).run(args);
    }

}</pre><p>The server has a home page with a UI, and HTTP API endpoints per the
normal Eureka functionality under <code class="literal">/eureka/*</code>.</p><p>Eureka background reading: see <a class="link" href="https://github.com/cfregly/fluxcapacitor/wiki/NetflixOSS-FAQ#eureka-service-discovery-load-balancer" target="_top">flux capacitor</a> and <a class="link" href="https://groups.google.com/forum/?fromgroups#!topic/eureka_netflix/g3p2r7gHnN0" target="_top">google group discussion</a>.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>Due to Gradle&#8217;s dependency resolution rules and the lack of a parent bom feature, simply depending on spring-cloud-starter-eureka-server can cause failures on application startup. To remedy this the Spring Boot Gradle plugin must be added and the Spring cloud starter parent bom must be imported like so:</p><p><b>build.gradle.&nbsp;</b>
</p><pre class="programlisting">buildscript {
  dependencies {
    classpath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.boot:spring-boot-gradle-plugin:1.5.10.RELEASE"</span>)
  }
}

apply plugin: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"spring-boot"</span>

dependencyManagement {
  imports {
    mavenBom <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.cloud:spring-cloud-dependencies:Dalston.SR5"</span>
  }
}</pre><p>
</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spring-cloud-eureka-server-zones-and-regions" href="#spring-cloud-eureka-server-zones-and-regions"></a>2.3&nbsp;High Availability, Zones and Regions</h2></div></div></div><p>The Eureka server does not have a backend store, but the service
instances in the registry all have to send heartbeats to keep their
registrations up to date (so this can be done in memory). Clients also
have an in-memory cache of eureka registrations (so they don&#8217;t have to
go to the registry for every single request to a service).</p><p>By default every Eureka server is also a Eureka client and requires
(at least one) service URL to locate a peer. If you don&#8217;t provide it
the service will run and work, but it will shower your logs with a lot
of noise about not being able to register with the peer.</p><p>See also <a class="link" href="#spring-cloud-ribbon" title="6.&nbsp;Client Side Load Balancer: Ribbon">below for details of Ribbon
support</a> on the client side for Zones and Regions.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_standalone_mode" href="#_standalone_mode"></a>2.4&nbsp;Standalone Mode</h2></div></div></div><p>The combination of the two caches (client and server) and the
heartbeats make a standalone Eureka server fairly resilient to
failure, as long as there is some sort of monitor or elastic runtime
keeping it alive (e.g. Cloud Foundry). In standalone mode, you might
prefer to switch off the client side behaviour, so it doesn&#8217;t keep
trying and failing to reach its peers. Example:</p><p><b>application.yml (Standalone Eureka Server).&nbsp;</b>
</p><pre class="screen">server:
  port: 8761

eureka:
  instance:
    hostname: localhost
  client:
    registerWithEureka: false
    fetchRegistry: false
    serviceUrl:
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/</pre><p>
</p><p>Notice that the <code class="literal">serviceUrl</code> is pointing to the same host as the local
instance.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_peer_awareness" href="#_peer_awareness"></a>2.5&nbsp;Peer Awareness</h2></div></div></div><p>Eureka can be made even more resilient and available by running
multiple instances and asking them to register with each other. In
fact, this is the default behaviour, so all you need to do to make it
work is add a valid <code class="literal">serviceUrl</code> to a peer, e.g.</p><p><b>application.yml (Two Peer Aware Eureka Servers).&nbsp;</b>
</p><pre class="screen">---
spring:
  profiles: peer1
eureka:
  instance:
    hostname: peer1
  client:
    serviceUrl:
      defaultZone: http://peer2/eureka/

---
spring:
  profiles: peer2
eureka:
  instance:
    hostname: peer2
  client:
    serviceUrl:
      defaultZone: http://peer1/eureka/</pre><p>
</p><p>In this example we have a YAML file that can be used to run the same
server on 2 hosts (peer1 and peer2), by running it in different
Spring profiles. You could use this configuration to test the peer
awareness on a single host (there&#8217;s not much value in doing that in
production) by manipulating <code class="literal">/etc/hosts</code> to resolve the host names. In
fact, the <code class="literal">eureka.instance.hostname</code> is not needed if you are running
on a machine that knows its own hostname (it is looked up using
<code class="literal">java.net.InetAddress</code> by default).</p><p>You can add multiple peers to a system, and as long as they are all
connected to each other by at least one edge, they will synchronize
the registrations amongst themselves. If the peers are physically
separated (inside a data centre or between multiple data centres) then
the system can in principle survive split-brain type failures.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_prefer_ip_address" href="#_prefer_ip_address"></a>2.6&nbsp;Prefer IP Address</h2></div></div></div><p>In some cases, it is preferable for Eureka to advertise the IP Adresses
of services rather than the hostname.  Set <code class="literal">eureka.instance.preferIpAddress</code>
to <code class="literal">true</code> and when the application registers with eureka, it will use its
IP Address rather than its hostname.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="_circuit_breaker_hystrix_clients" href="#_circuit_breaker_hystrix_clients"></a>3.&nbsp;Circuit Breaker: Hystrix Clients</h1></div></div></div><p>Netflix has created a library called <a class="link" href="https://github.com/Netflix/Hystrix" target="_top">Hystrix</a> that implements the <a class="link" href="https://martinfowler.com/bliki/CircuitBreaker.html" target="_top">circuit breaker pattern</a>.  In a microservice architecture it is common to have multiple layers of service calls.</p><div class="figure"><a name="d0e534" href="#d0e534"></a><p class="title"><b>Figure&nbsp;3.1.&nbsp;Microservice Graph</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/HystrixGraph.png" alt="HystrixGraph"></div></div></div><br class="figure-break"><p>A service failure in the lower level of services can cause cascading failure all the way up to the user. When calls to a particular service is greater than <code class="literal">circuitBreaker.requestVolumeThreshold</code> (default: 20 requests) and failue percentage is greater than <code class="literal">circuitBreaker.errorThresholdPercentage</code> (default: &gt;50%) in a rolling window defined  by <code class="literal">metrics.rollingStats.timeInMilliseconds</code> (default: 10 seconds), the circuit opens and the call is not made.  In cases of error and an open circuit a fallback can be provided by the developer.</p><div class="figure"><a name="d0e554" href="#d0e554"></a><p class="title"><b>Figure&nbsp;3.2.&nbsp;Hystrix fallback prevents cascading failures</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/HystrixFallback.png" alt="HystrixFallback"></div></div></div><br class="figure-break"><p>Having an open circuit stops cascading failures and allows overwhelmed or failing services time to heal.  The fallback can be another Hystrix protected call, static data or a sane empty value.  Fallbacks may be chained so the first fallback makes some other business call which in turn falls back to static data.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="netflix-hystrix-starter" href="#netflix-hystrix-starter"></a>3.1&nbsp;How to Include Hystrix</h2></div></div></div><p>To include Hystrix in your project use the starter with group <code class="literal">org.springframework.cloud</code>
and artifact id <code class="literal">spring-cloud-starter-hystrix</code>. See the <a class="link" href="https://projects.spring.io/spring-cloud/" target="_top">Spring Cloud Project page</a>
for details on setting up your build system with the current Spring Cloud Release Train.</p><p>Example boot app:</p><pre class="screen">@SpringBootApplication
@EnableCircuitBreaker
public class Application {

    public static void main(String[] args) {
        new SpringApplicationBuilder(Application.class).web(true).run(args);
    }

}

@Component
public class StoreIntegration {

    @HystrixCommand(fallbackMethod = "defaultStores")
    public Object getStores(Map&lt;String, Object&gt; parameters) {
        //do stuff that might fail
    }

    public Object defaultStores(Map&lt;String, Object&gt; parameters) {
        return /* something useful */;
    }
}</pre><p>The <code class="literal">@HystrixCommand</code> is provided by a Netflix contrib library called
<a class="link" href="https://github.com/Netflix/Hystrix/tree/master/hystrix-contrib/hystrix-javanica" target="_top">"javanica"</a>.
Spring Cloud automatically wraps Spring beans with that
annotation in a proxy that is connected to the Hystrix circuit
breaker. The circuit breaker calculates when to open and close the
circuit, and what to do in case of a failure.</p><p>To configure the <code class="literal">@HystrixCommand</code> you can use the <code class="literal">commandProperties</code>
attribute with a list of <code class="literal">@HystrixProperty</code> annotations.  See
<a class="link" href="https://github.com/Netflix/Hystrix/tree/master/hystrix-contrib/hystrix-javanica#configuration" target="_top">here</a>
for more details.  See the <a class="link" href="https://github.com/Netflix/Hystrix/wiki/Configuration" target="_top">Hystrix wiki</a>
for details on the properties available.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_propagating_the_security_context_or_using_spring_scopes" href="#_propagating_the_security_context_or_using_spring_scopes"></a>3.2&nbsp;Propagating the Security Context or using Spring Scopes</h2></div></div></div><p>If you want some thread local context to propagate into a <code class="literal">@HystrixCommand</code> the default declaration will not work because it executes the command in a thread pool (in case of timeouts). You can switch Hystrix to use the same thread as the caller using some configuration, or directly in the annotation, by asking it to use a different "Isolation Strategy". For example:</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@HystrixCommand(fallbackMethod = "stubMyService",
    commandProperties = {
      @HystrixProperty(name="execution.isolation.strategy", value="SEMAPHORE")
    }
)</span></em>
...</pre><p>The same thing applies if you are using <code class="literal">@SessionScope</code> or <code class="literal">@RequestScope</code>. You will know when you need to do this because of a runtime exception that says it can&#8217;t find the scoped context.</p><p>You also have the option to set the <code class="literal">hystrix.shareSecurityContext</code> property to <code class="literal">true</code>. Doing so will auto configure an Hystrix concurrency strategy plugin hook who will transfer the <code class="literal">SecurityContext</code> from your main thread to the one used by the Hystrix command. Hystrix does not allow multiple hystrix concurrency strategy to be registered so an extension mechanism is available by declaring your own <code class="literal">HystrixConcurrencyStrategy</code> as a Spring bean. Spring Cloud will lookup for your implementation within the Spring context and wrap it inside its own plugin.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_health_indicator" href="#_health_indicator"></a>3.3&nbsp;Health Indicator</h2></div></div></div><p>The state of the connected circuit breakers are also exposed in the
<code class="literal">/health</code> endpoint of the calling application.</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"hystrix"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"openCircuitBreakers"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">[</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"StoreIntegration::getStoresByLocationLink"</span>
        ]<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"status"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"CIRCUIT_OPEN"</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"status"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"UP"</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span></pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_hystrix_metrics_stream" href="#_hystrix_metrics_stream"></a>3.4&nbsp;Hystrix Metrics Stream</h2></div></div></div><p>To enable the Hystrix metrics stream include a dependency on <code class="literal">spring-boot-starter-actuator</code>.  This will expose the <code class="literal">/hystrix.stream</code> as a management endpoint.</p><pre class="programlisting">    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.boot<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-boot-starter-actuator<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="_circuit_breaker_hystrix_dashboard" href="#_circuit_breaker_hystrix_dashboard"></a>4.&nbsp;Circuit Breaker: Hystrix Dashboard</h1></div></div></div><p>One of the main benefits of Hystrix is the set of metrics it gathers about each HystrixCommand.  The Hystrix Dashboard displays the health of each circuit breaker in an efficient manner.</p><div class="figure"><a name="d0e668" href="#d0e668"></a><p class="title"><b>Figure&nbsp;4.1.&nbsp;Hystrix Dashboard</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/Hystrix.png" alt="Hystrix"></div></div></div><br class="figure-break"></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="_hystrix_timeouts_and_ribbon_clients" href="#_hystrix_timeouts_and_ribbon_clients"></a>5.&nbsp;Hystrix Timeouts And Ribbon Clients</h1></div></div></div><p>When using Hystrix commands that wrap Ribbon clients you want to make sure your Hystrix timeout
is configured to be longer than the configured Ribbon timeout, including any potential
retries that might be made.  For example, if your Ribbon connection timeout is one second and
the Ribbon client might retry the request three times, than your Hystrix timeout should
be slightly more than three seconds.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="netflix-hystrix-dashboard-starter" href="#netflix-hystrix-dashboard-starter"></a>5.1&nbsp;How to Include Hystrix Dashboard</h2></div></div></div><p>To include the Hystrix Dashboard in your project use the starter with group <code class="literal">org.springframework.cloud</code>
and artifact id <code class="literal">spring-cloud-starter-hystrix-dashboard</code>. See the <a class="link" href="https://projects.spring.io/spring-cloud/" target="_top">Spring Cloud Project page</a>
for details on setting up your build system with the current Spring Cloud Release Train.</p><p>To run the Hystrix Dashboard annotate your Spring Boot main class with <code class="literal">@EnableHystrixDashboard</code>.  You then visit <code class="literal">/hystrix</code> and point the dashboard to an individual instances <code class="literal">/hystrix.stream</code> endpoint in a Hystrix client application.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>When connecting to a <code class="literal">/hystrix.stream</code> endpoint which uses HTTPS the certificate used by the server
must be trusted by the JVM.  If the certificate is not trusted you must import the certificate into the JVM
in order for the Hystrix Dashboard to make a successful connection to the stream endpoint.</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_turbine" href="#_turbine"></a>5.2&nbsp;Turbine</h2></div></div></div><p>Looking at an individual instances Hystrix data is not very useful in terms of the overall health of the system.  <a class="link" href="https://github.com/Netflix/Turbine" target="_top">Turbine</a> is an application that aggregates all of the relevant <code class="literal">/hystrix.stream</code> endpoints into a combined <code class="literal">/turbine.stream</code> for use in the Hystrix Dashboard.  Individual instances are located via Eureka.  Running Turbine is as simple as annotating your main class with the <code class="literal">@EnableTurbine</code> annotation  (e.g. using spring-cloud-starter-turbine to set up the classpath).  All of the documented configuration properties from <a class="link" href="https://github.com/Netflix/Turbine/wiki/Configuration-(1.x)" target="_top">the Turbine 1 wiki</a> apply.  The only difference is that the <code class="literal">turbine.instanceUrlSuffix</code> does not need the port prepended as this is handled automatically unless <code class="literal">turbine.instanceInsertPort=false</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>By default, Turbine looks for the <code class="literal">/hystrix.stream</code> endpoint on a registered instance by looking up its <code class="literal">homePageUrl</code> entry in Eureka, then appending <code class="literal">/hystrix.stream</code> to it. This means that if <code class="literal">spring-boot-actuator</code> is running on its own port (which is the default), the call to <code class="literal">/hystrix.stream</code> will fail.
To make turbine find the Hystrix stream at the correct port, you need to add <code class="literal">management.port</code> to the instances' metadata:</p></td></tr></table></div><pre class="screen">eureka:
  instance:
    metadata-map:
      management.port: ${management.port:8081}</pre><p>The configuration key <code class="literal">turbine.appConfig</code> is a list of eureka serviceIds that turbine will use to lookup instances.  The turbine stream is then used in the Hystrix dashboard using a url that looks like: <code class="literal"><a class="link" href="https://my.turbine.sever:8080/turbine.stream?cluster=CLUSTERNAME" target="_top">https://my.turbine.sever:8080/turbine.stream?cluster=CLUSTERNAME</a></code> (the cluster parameter can be omitted if the name is "default"). The <code class="literal">cluster</code> parameter must match an entry in <code class="literal">turbine.aggregator.clusterConfig</code>. Values returned from eureka are uppercase, thus we expect this example to work if there is an app registered with Eureka called "customers":</p><pre class="screen">turbine:
  aggregator:
    clusterConfig: CUSTOMERS
  appConfig: customers</pre><p>The <code class="literal">clusterName</code> can be customized by a SPEL expression in <code class="literal">turbine.clusterNameExpression</code> with root an instance of <code class="literal">InstanceInfo</code>. The default value is <code class="literal">appName</code>, which means that the Eureka serviceId ends up as the cluster key (i.e. the <code class="literal">InstanceInfo</code> for customers has an <code class="literal">appName</code> of "CUSTOMERS").  A different example would be <code class="literal">turbine.clusterNameExpression=aSGName</code>, which would get the cluster name from the AWS ASG name. Another example:</p><pre class="screen">turbine:
  aggregator:
    clusterConfig: SYSTEM,USER
  appConfig: customers,stores,ui,admin
  clusterNameExpression: metadata['cluster']</pre><p>In this case, the cluster name from 4 services is pulled from their metadata map, and is expected to have values that include "SYSTEM" and "USER".</p><p>To use the "default" cluster for all apps you need a string literal expression (with single quotes, and escaped with double quotes if it is in YAML as well):</p><pre class="screen">turbine:
  appConfig: customers,stores
  clusterNameExpression: "'default'"</pre><p>Spring Cloud provides a <code class="literal">spring-cloud-starter-turbine</code> that has all the dependencies you need to get a Turbine server running. Just create a Spring Boot application and annotate it with <code class="literal">@EnableTurbine</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>by default Spring Cloud allows Turbine to use the host and port to allow multiple processes per host, per cluster. If you want the native Netflix behaviour built into Turbine that does <span class="emphasis"><em>not</em></span> allow multiple processes per host, per cluster (the key to the instance id is the hostname), then set the property <code class="literal">turbine.combineHostPort=false</code>.</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_turbine_stream" href="#_turbine_stream"></a>5.3&nbsp;Turbine Stream</h2></div></div></div><p>In some environments (e.g. in a PaaS setting), the classic Turbine model of pulling metrics from all the distributed Hystrix commands doesn&#8217;t work. In that case you might want to have your Hystrix commands push metrics to Turbine, and Spring Cloud enables that with messaging. All you need to do on the client is add a dependency to <code class="literal">spring-cloud-netflix-hystrix-stream</code> and the <code class="literal">spring-cloud-starter-stream-*</code> of your choice (see Spring Cloud Stream documentation for details on the brokers, and how to configure the client credentials, but it should work out of the box for a local broker).</p><p>On the server side Just create a Spring Boot application and annotate it with <code class="literal">@EnableTurbineStream</code> and by default it will come up on port 8989 (point your Hystrix dashboard to that port, any path). You can customize the port using either <code class="literal">server.port</code> or <code class="literal">turbine.stream.port</code>. If you have <code class="literal">spring-boot-starter-web</code> and <code class="literal">spring-boot-starter-actuator</code> on the classpath as well, then you can open up the Actuator endpoints on a separate port (with Tomcat by default) by providing a <code class="literal">management.port</code> which is different.</p><p>You can then point the Hystrix Dashboard to the Turbine Stream Server instead of individual Hystrix streams.  If Turbine Stream is running on port 8989 on myhost, then put <code class="literal"><a class="link" href="http://myhost:8989" target="_top">http://myhost:8989</a></code> in the stream input field in the Hystrix Dashboard. Circuits will be prefixed by their respective serviceId, followed by a dot, then the circuit name.</p><p>Spring Cloud provides a <code class="literal">spring-cloud-starter-turbine-stream</code> that has all the dependencies you need to get a Turbine Stream server running - just add the Stream binder of your choice, e.g. <code class="literal">spring-cloud-starter-stream-rabbit</code>. You need Java 8 to run the app because it is Netty-based.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="spring-cloud-ribbon" href="#spring-cloud-ribbon"></a>6.&nbsp;Client Side Load Balancer: Ribbon</h1></div></div></div><p>Ribbon is a client side load balancer which gives you a lot of control
over the behaviour of HTTP and TCP clients. Feign already uses Ribbon,
so if you are using <code class="literal">@FeignClient</code> then this section also applies.</p><p>A central concept in Ribbon is that of the named client. Each load
balancer is part of an ensemble of components that work together to
contact a remote server on demand, and the ensemble has a name that
you give it as an application developer (e.g. using the <code class="literal">@FeignClient</code>
annotation). Spring Cloud creates a new ensemble as an
<code class="literal">ApplicationContext</code> on demand for each named client using
<code class="literal">RibbonClientConfiguration</code>. This contains (amongst other things) an
<code class="literal">ILoadBalancer</code>, a <code class="literal">RestClient</code>, and a <code class="literal">ServerListFilter</code>.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="netflix-ribbon-starter" href="#netflix-ribbon-starter"></a>6.1&nbsp;How to Include Ribbon</h2></div></div></div><p>To include Ribbon in your project use the starter with group <code class="literal">org.springframework.cloud</code>
and artifact id <code class="literal">spring-cloud-starter-ribbon</code>. See the <a class="link" href="https://projects.spring.io/spring-cloud/" target="_top">Spring Cloud Project page</a>
for details on setting up your build system with the current Spring Cloud Release Train.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_customizing_the_ribbon_client" href="#_customizing_the_ribbon_client"></a>6.2&nbsp;Customizing the Ribbon Client</h2></div></div></div><p>You can configure some bits of a Ribbon client using external
properties in <code class="literal">&lt;client&gt;.ribbon.*</code>, which is no different than using
the Netflix APIs natively, except that you can use Spring Boot
configuration files. The native options can
be inspected as static fields in <code class="literal">CommonClientConfigKey</code> (part of
ribbon-core).</p><p>Spring Cloud also lets you take full control of the client by
declaring additional configuration (on top of the
<code class="literal">RibbonClientConfiguration</code>) using <code class="literal">@RibbonClient</code>. Example:</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<em><span class="hl-annotation" style="color: gray">@RibbonClient(name = "foo", configuration = FooConfiguration.class)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> TestConfiguration {
}</pre><p>In this case the client is composed from the components already in
<code class="literal">RibbonClientConfiguration</code> together with any in <code class="literal">FooConfiguration</code>
(where the latter generally will override the former).</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="images/warning.png"></td><th align="left">Warning</th></tr><tr><td align="left" valign="top"><p>The <code class="literal">FooConfiguration</code> has to be <code class="literal">@Configuration</code> but take
care that it is not in a <code class="literal">@ComponentScan</code> for the main application
context, otherwise it will be shared by all the <code class="literal">@RibbonClients</code>. If
you use <code class="literal">@ComponentScan</code> (or <code class="literal">@SpringBootApplication</code>) you need to
take steps to avoid it being included (for instance put it in a
separate, non-overlapping package, or specify the packages to scan
explicitly in the <code class="literal">@ComponentScan</code>).</p></td></tr></table></div><p>Spring Cloud Netflix provides the following beans by default for ribbon
(<code class="literal">BeanType</code> beanName: <code class="literal">ClassName</code>):</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><code class="literal">IClientConfig</code> ribbonClientConfig: <code class="literal">DefaultClientConfigImpl</code></li><li class="listitem"><code class="literal">IRule</code> ribbonRule: <code class="literal">ZoneAvoidanceRule</code></li><li class="listitem"><code class="literal">IPing</code> ribbonPing: <code class="literal">NoOpPing</code></li><li class="listitem"><code class="literal">ServerList&lt;Server&gt;</code> ribbonServerList: <code class="literal">ConfigurationBasedServerList</code></li><li class="listitem"><code class="literal">ServerListFilter&lt;Server&gt;</code> ribbonServerListFilter: <code class="literal">ZonePreferenceServerListFilter</code></li><li class="listitem"><code class="literal">ILoadBalancer</code> ribbonLoadBalancer: <code class="literal">ZoneAwareLoadBalancer</code></li><li class="listitem"><code class="literal">ServerListUpdater</code> ribbonServerListUpdater: <code class="literal">PollingServerListUpdater</code></li></ul></div><p>Creating a bean of one of those type and placing it in a <code class="literal">@RibbonClient</code>
configuration (such as <code class="literal">FooConfiguration</code> above) allows you to override each
one of the beans described.  Example:</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> FooConfiguration {
    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> IPing ribbonPing(IClientConfig config) {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> PingUrl();
    }
}</pre><p>This replaces the <code class="literal">NoOpPing</code> with <code class="literal">PingUrl</code>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_customizing_the_ribbon_client_using_properties" href="#_customizing_the_ribbon_client_using_properties"></a>6.3&nbsp;Customizing the Ribbon Client using properties</h2></div></div></div><p>Starting with version 1.2.0, Spring Cloud Netflix now supports customizing Ribbon clients using properties to be compatible with the <a class="link" href="https://github.com/Netflix/ribbon/wiki/Working-with-load-balancers#components-of-load-balancer" target="_top">Ribbon documentation</a>.</p><p>This allows you to change behavior at start up time in different environments.</p><p>The supported properties are listed below and should be prefixed by <code class="literal">&lt;clientName&gt;.ribbon.</code>:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><code class="literal">NFLoadBalancerClassName</code>: should implement <code class="literal">ILoadBalancer</code></li><li class="listitem"><code class="literal">NFLoadBalancerRuleClassName</code>: should implement <code class="literal">IRule</code></li><li class="listitem"><code class="literal">NFLoadBalancerPingClassName</code>: should implement <code class="literal">IPing</code></li><li class="listitem"><code class="literal">NIWSServerListClassName</code>: should implement <code class="literal">ServerList</code></li><li class="listitem"><code class="literal">NIWSServerListFilterClassName</code> should implement <code class="literal">ServerListFilter</code></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Classes defined in these properties have precedence over beans defined using <code class="literal">@RibbonClient(configuration=MyRibbonConfig.class)</code> and the defaults provided by Spring Cloud Netflix.</p></td></tr></table></div><p>To set the <code class="literal">IRule</code> for a service name <code class="literal">users</code> you could set the following:</p><p><b>application.yml.&nbsp;</b>
</p><pre class="screen">users:
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.WeightedResponseTimeRule</pre><p>
</p><p>See the <a class="link" href="https://github.com/Netflix/ribbon/wiki/Working-with-load-balancers" target="_top">Ribbon documentation</a> for implementations provided by Ribbon.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_using_ribbon_with_eureka" href="#_using_ribbon_with_eureka"></a>6.4&nbsp;Using Ribbon with Eureka</h2></div></div></div><p>When Eureka is used in conjunction with Ribbon (i.e., both are on the classpath) the <code class="literal">ribbonServerList</code>
is overridden with an extension of <code class="literal">DiscoveryEnabledNIWSServerList</code>
which populates the list of servers from Eureka.  It also replaces the
<code class="literal">IPing</code> interface with <code class="literal">NIWSDiscoveryPing</code> which delegates to Eureka
to determine if a server is up. The <code class="literal">ServerList</code> that is installed by
default is a <code class="literal">DomainExtractingServerList</code> and the purpose of this is
to make physical metadata available to the load balancer without using
AWS AMI metadata (which is what Netflix relies on). By default the
server list will be constructed with "zone" information as provided in
the instance metadata (so on the remote clients set
<code class="literal">eureka.instance.metadataMap.zone</code>), and if that is missing it can use
the domain name from the server hostname as a proxy for zone (if the
flag <code class="literal">approximateZoneFromHostname</code> is set). Once the zone information
is available it can be used in a <code class="literal">ServerListFilter</code>. By default it
will be used to locate a server in the same zone as the client because
the default is a <code class="literal">ZonePreferenceServerListFilter</code>. The zone of the
client is determined the same way as the remote instances by default,
i.e. via <code class="literal">eureka.instance.metadataMap.zone</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>The orthodox "archaius" way to set the client zone is via a
configuration property called "@zone", and Spring Cloud will use that
in preference to all other settings if it is available (note that the
key will have to be quoted in YAML configuration).</p></td></tr></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>If there is no other source of zone data then a guess is made
based on the client configuration (as opposed to the instance
configuration). We take <code class="literal">eureka.client.availabilityZones</code>, which is a
map from region name to a list of zones, and pull out the first zone
for the instance&#8217;s own region (i.e. the <code class="literal">eureka.client.region</code>, which
defaults to "us-east-1" for comatibility with native Netflix).</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spring-cloud-ribbon-without-eureka" href="#spring-cloud-ribbon-without-eureka"></a>6.5&nbsp;Example: How to Use Ribbon Without Eureka</h2></div></div></div><p>Eureka is a convenient way to abstract the discovery of remote servers
so you don&#8217;t have to hard code their URLs in clients, but if you
prefer not to use it, Ribbon and Feign are still quite
amenable. Suppose you have declared a <code class="literal">@RibbonClient</code> for "stores",
and Eureka is not in use (and not even on the classpath). The Ribbon
client defaults to a configured server list, and you can supply the
configuration like this</p><p><b>application.yml.&nbsp;</b>
</p><pre class="screen">stores:
  ribbon:
    listOfServers: example.com,google.com</pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_example_disable_eureka_use_in_ribbon" href="#_example_disable_eureka_use_in_ribbon"></a>6.6&nbsp;Example: Disable Eureka use in Ribbon</h2></div></div></div><p>Setting the property <code class="literal">ribbon.eureka.enabled = false</code> will explicitly
disable the use of Eureka in Ribbon.</p><p><b>application.yml.&nbsp;</b>
</p><pre class="screen">ribbon:
  eureka:
   enabled: false</pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_using_the_ribbon_api_directly" href="#_using_the_ribbon_api_directly"></a>6.7&nbsp;Using the Ribbon API Directly</h2></div></div></div><p>You can also use the <code class="literal">LoadBalancerClient</code> directly. Example:</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MyClass {
    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> LoadBalancerClient loadBalancer;

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> doStuff() {
        ServiceInstance instance = loadBalancer.choose(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"stores"</span>);
        URI storesUri = URI.create(String.format(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"http://%s:%s"</span>, instance.getHost(), instance.getPort()));
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// ... do something with the URI</span>
    }
}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ribbon-child-context-eager-load" href="#ribbon-child-context-eager-load"></a>6.8&nbsp;Caching of Ribbon Configuration</h2></div></div></div><p>Each Ribbon named client has a corresponding child Application Context that Spring Cloud maintains, this application context is lazily loaded up on the first request to the named client.
This lazy loading behavior can be changed to instead eagerly load up these child Application contexts at startup by specifying the names of the Ribbon clients.</p><p><b>application.yml.&nbsp;</b>
</p><pre class="screen">ribbon:
  eager-load:
    enabled: true
    clients: client1, client2, client3</pre><p>
</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="spring-cloud-feign" href="#spring-cloud-feign"></a>7.&nbsp;Declarative REST Client: Feign</h1></div></div></div><p><a class="link" href="https://github.com/Netflix/feign" target="_top">Feign</a> is a declarative web service client.  It makes writing web service clients easier.  To use Feign create an interface and annotate it.  It has pluggable annotation support including Feign annotations and JAX-RS annotations. Feign also supports pluggable encoders and decoders.  Spring Cloud adds support for Spring MVC annotations and for using the same <code class="literal">HttpMessageConverters</code> used by default in Spring Web.  Spring Cloud integrates Ribbon and Eureka to provide a load balanced http client when using Feign.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="netflix-feign-starter" href="#netflix-feign-starter"></a>7.1&nbsp;How to Include Feign</h2></div></div></div><p>To include Feign in your project use the starter with group <code class="literal">org.springframework.cloud</code>
and artifact id <code class="literal">spring-cloud-starter-feign</code>. See the <a class="link" href="https://projects.spring.io/spring-cloud/" target="_top">Spring Cloud Project page</a>
for details on setting up your build system with the current Spring Cloud Release Train.</p><p>Example spring boot app</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<em><span class="hl-annotation" style="color: gray">@ComponentScan</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableAutoConfiguration</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableEurekaClient</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableFeignClients</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Application {

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(String[] args) {
        SpringApplication.run(Application.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, args);
    }

}</pre><p><b>StoreClient.java.&nbsp;</b>
</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@FeignClient("stores")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> StoreClient {
    <em><span class="hl-annotation" style="color: gray">@RequestMapping(method = RequestMethod.GET, value = "/stores")</span></em>
    List&lt;Store&gt; getStores();

    <em><span class="hl-annotation" style="color: gray">@RequestMapping(method = RequestMethod.POST, value = "/stores/{storeId}", consumes = "application/json")</span></em>
    Store update(<em><span class="hl-annotation" style="color: gray">@PathVariable("storeId")</span></em> Long storeId, Store store);
}</pre><p>
</p><p>In the <code class="literal">@FeignClient</code> annotation the String value ("stores" above) is
an arbitrary client name, which is used to create a Ribbon load
balancer (see <a class="link" href="#spring-cloud-ribbon" title="6.&nbsp;Client Side Load Balancer: Ribbon">below for details of Ribbon
support</a>). You can also specify a URL using the <code class="literal">url</code> attribute
(absolute value or just a hostname). The name of the bean in the
application context is the fully qualified name of the interface.
To specify your own alias value you can use the <code class="literal">qualifier</code> value
of the <code class="literal">@FeignClient</code> annotation.</p><p>The Ribbon client above will want to discover the physical addresses
for the "stores" service. If your application is a Eureka client then
it will resolve the service in the Eureka service registry. If you
don&#8217;t want to use Eureka, you can simply configure a list of servers
in your external configuration (see
<a class="link" href="#spring-cloud-ribbon-without-eureka" title="6.5&nbsp;Example: How to Use Ribbon Without Eureka">above for example</a>).</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spring-cloud-feign-overriding-defaults" href="#spring-cloud-feign-overriding-defaults"></a>7.2&nbsp;Overriding Feign Defaults</h2></div></div></div><p>A central concept in Spring Cloud&#8217;s Feign support is that of the named client. Each feign client is part of an ensemble of components that work together to contact a remote server on demand, and the ensemble has a name that you give it as an application developer using the <code class="literal">@FeignClient</code> annotation. Spring Cloud creates a new ensemble as an
<code class="literal">ApplicationContext</code> on demand for each named client using <code class="literal">FeignClientsConfiguration</code>. This contains (amongst other things) an <code class="literal">feign.Decoder</code>, a <code class="literal">feign.Encoder</code>, and a <code class="literal">feign.Contract</code>.</p><p>Spring Cloud lets you take full control of the feign client by declaring additional configuration (on top of the <code class="literal">FeignClientsConfiguration</code>) using <code class="literal">@FeignClient</code>. Example:</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@FeignClient(name = "stores", configuration = FooConfiguration.class)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> StoreClient {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//..</span>
}</pre><p>In this case the client is composed from the components already in <code class="literal">FeignClientsConfiguration</code> together with any in <code class="literal">FooConfiguration</code> (where the latter will override the former).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p><code class="literal">FooConfiguration</code> does not need to be annotated with <code class="literal">@Configuration</code>. However, if it is, then take care to exclude it from any <code class="literal">@ComponentScan</code> that would otherwise include this configuration as it will become the default source for <code class="literal">feign.Decoder</code>, <code class="literal">feign.Encoder</code>, <code class="literal">feign.Contract</code>, etc., when specified. This can be avoided by putting it in a separate, non-overlapping package from any <code class="literal">@ComponentScan</code> or <code class="literal">@SpringBootApplication</code>, or it can be explicitly excluded in <code class="literal">@ComponentScan</code>.</p></td></tr></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>The <code class="literal">serviceId</code> attribute is now deprecated in favor of the <code class="literal">name</code> attribute.</p></td></tr></table></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="images/warning.png"></td><th align="left">Warning</th></tr><tr><td align="left" valign="top"><p>Previously, using the <code class="literal">url</code> attribute, did not require the <code class="literal">name</code> attribute. Using <code class="literal">name</code> is now required.</p></td></tr></table></div><p>Placeholders are supported in the <code class="literal">name</code> and <code class="literal">url</code> attributes.</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@FeignClient(name = "${feign.name}", url = "${feign.url}")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> StoreClient {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//..</span>
}</pre><p>Spring Cloud Netflix provides the following beans by default for feign (<code class="literal">BeanType</code> beanName: <code class="literal">ClassName</code>):</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><code class="literal">Decoder</code> feignDecoder: <code class="literal">ResponseEntityDecoder</code> (which wraps a <code class="literal">SpringDecoder</code>)</li><li class="listitem"><code class="literal">Encoder</code> feignEncoder: <code class="literal">SpringEncoder</code></li><li class="listitem"><code class="literal">Logger</code> feignLogger: <code class="literal">Slf4jLogger</code></li><li class="listitem"><code class="literal">Contract</code> feignContract: <code class="literal">SpringMvcContract</code></li><li class="listitem"><code class="literal">Feign.Builder</code> feignBuilder: <code class="literal">HystrixFeign.Builder</code></li><li class="listitem"><code class="literal">Client</code> feignClient: if Ribbon is enabled it is a <code class="literal">LoadBalancerFeignClient</code>, otherwise the default feign client is used.</li></ul></div><p>The OkHttpClient and ApacheHttpClient feign clients can be used by setting <code class="literal">feign.okhttp.enabled</code> or <code class="literal">feign.httpclient.enabled</code> to <code class="literal">true</code>, respectively, and having them on the classpath.</p><p>Spring Cloud Netflix <span class="emphasis"><em>does not</em></span> provide the following beans by default for feign, but still looks up beans of these types from the application context to create the feign client:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><code class="literal">Logger.Level</code></li><li class="listitem"><code class="literal">Retryer</code></li><li class="listitem"><code class="literal">ErrorDecoder</code></li><li class="listitem"><code class="literal">Request.Options</code></li><li class="listitem"><code class="literal">Collection&lt;RequestInterceptor&gt;</code></li><li class="listitem"><code class="literal">SetterFactory</code></li></ul></div><p>Creating a bean of one of those type and placing it in a <code class="literal">@FeignClient</code> configuration (such as <code class="literal">FooConfiguration</code> above) allows you to override each one of the beans described.  Example:</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> FooConfiguration {
    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Contract feignContract() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> feign.Contract.Default();
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> BasicAuthRequestInterceptor basicAuthRequestInterceptor() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> BasicAuthRequestInterceptor(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"user"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"password"</span>);
    }
}</pre><p>This replaces the <code class="literal">SpringMvcContract</code> with <code class="literal">feign.Contract.Default</code> and adds a <code class="literal">RequestInterceptor</code> to the collection of <code class="literal">RequestInterceptor</code>.</p><p>Default configurations can be specified in the <code class="literal">@EnableFeignClients</code> attribute <code class="literal">defaultConfiguration</code> in a similar manner as described above. The difference is that this configuration will apply to <span class="emphasis"><em>all</em></span> feign clients.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>If you need to use <code class="literal">ThreadLocal</code> bound variables in your <code class="literal">RequestInterceptor`s you will need to either set the
thread isolation strategy for Hystrix to `SEMAPHORE</code> or disable Hystrix in Feign.</p></td></tr></table></div><p>application.yml</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># To disable Hystrix in Feign</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">feign</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  hystrix</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    enabled</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">false</span>

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># To set thread isolation to SEMAPHORE</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">hystrix</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  command</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    default</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      execution</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        isolation</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          strategy</span>: SEMAPHORE</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_creating_feign_clients_manually" href="#_creating_feign_clients_manually"></a>7.3&nbsp;Creating Feign Clients Manually</h2></div></div></div><p>In some cases it might be necessary to customize your Feign Clients in a way that is not
possible using the methods above.  In this case you can create Clients using the
<a class="link" href="https://github.com/OpenFeign/feign/#basics" target="_top">Feign Builder API</a>. Below is an example
which creates two Feign Clients with the same interface but configures each one with
a separate request interceptor.</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Import(FeignClientsConfiguration.class)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> FooController {

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> FooClient fooClient;

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> FooClient adminClient;

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> FooController(
			Decoder decoder, Encoder encoder, Client client) {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.fooClient = Feign.builder().client(client)
				.encoder(encoder)
				.decoder(decoder)
				.requestInterceptor(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> BasicAuthRequestInterceptor(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"user"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"user"</span>))
				.target(FooClient.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"http://PROD-SVC"</span>);
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.adminClient = Feign.builder().client(client)
				.encoder(encoder)
				.decoder(decoder)
				.requestInterceptor(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> BasicAuthRequestInterceptor(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"admin"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"admin"</span>))
				.target(FooClient.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"http://PROD-SVC"</span>);
    }
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>In the above example <code class="literal">FeignClientsConfiguration.class</code> is the default configuration
provided by Spring Cloud Netflix.</p></td></tr></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p><code class="literal">PROD-SVC</code> is the name of the service the Clients will be making requests to.</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spring-cloud-feign-hystrix" href="#spring-cloud-feign-hystrix"></a>7.4&nbsp;Feign Hystrix Support</h2></div></div></div><p>If Hystrix is on the classpath and <code class="literal">feign.hystrix.enabled=true</code>, Feign will wrap all methods with a circuit breaker. Returning a <code class="literal">com.netflix.hystrix.HystrixCommand</code> is also available. This lets you use reactive patterns (with a call to <code class="literal">.toObservable()</code> or <code class="literal">.observe()</code> or asynchronous use (with a call to <code class="literal">.queue()</code>).</p><p>To disable Hystrix support on a per-client basis create a vanilla <code class="literal">Feign.Builder</code> with the "prototype" scope, e.g.:</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> FooConfiguration {
    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
	<em><span class="hl-annotation" style="color: gray">@Scope("prototype")</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Feign.Builder feignBuilder() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> Feign.builder();
	}
}</pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="images/warning.png"></td><th align="left">Warning</th></tr><tr><td align="left" valign="top"><p>Prior to the Spring Cloud Dalston release, if Hystrix was on the classpath Feign would have wrapped
all methods in a circuit breaker by default.  This default behavior was changed in Spring Cloud Dalston in
favor for an opt-in approach.</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spring-cloud-feign-hystrix-fallback" href="#spring-cloud-feign-hystrix-fallback"></a>7.5&nbsp;Feign Hystrix Fallbacks</h2></div></div></div><p>Hystrix supports the notion of a fallback: a default code path that is executed when they circuit is open or there is an error. To enable fallbacks for a given <code class="literal">@FeignClient</code> set the <code class="literal">fallback</code> attribute to the class name that implements the fallback. You also need to declare your implementation as a Spring bean.</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@FeignClient(name = "hello", fallback = HystrixClientFallback.class)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">protected</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> HystrixClient {
    <em><span class="hl-annotation" style="color: gray">@RequestMapping(method = RequestMethod.GET, value = "/hello")</span></em>
    Hello iFailSometimes();
}

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> HystrixClientFallback <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">implements</span> HystrixClient {
    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Hello iFailSometimes() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Hello(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"fallback"</span>);
    }
}</pre><p>If one needs access to the cause that made the fallback trigger, one can use the <code class="literal">fallbackFactory</code> attribute inside <code class="literal">@FeignClient</code>.</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@FeignClient(name = "hello", fallbackFactory = HystrixClientFallbackFactory.class)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">protected</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> HystrixClient {
	<em><span class="hl-annotation" style="color: gray">@RequestMapping(method = RequestMethod.GET, value = "/hello")</span></em>
	Hello iFailSometimes();
}

<em><span class="hl-annotation" style="color: gray">@Component</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> HystrixClientFallbackFactory <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">implements</span> FallbackFactory&lt;HystrixClient&gt; {
	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> HystrixClient create(Throwable cause) {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> HystrixClientWithFallBackFactory() {
			<em><span class="hl-annotation" style="color: gray">@Override</span></em>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Hello iFailSometimes() {
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Hello(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"fallback; reason was: "</span> + cause.getMessage());
			}
		};
	}
}</pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="images/warning.png"></td><th align="left">Warning</th></tr><tr><td align="left" valign="top"><p>There is a limitation with the implementation of fallbacks in Feign and how Hystrix fallbacks work. Fallbacks are currently not supported for methods that return <code class="literal">com.netflix.hystrix.HystrixCommand</code> and <code class="literal">rx.Observable</code>.</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_feign_and_literal_primary_literal" href="#_feign_and_literal_primary_literal"></a>7.6&nbsp;Feign and <code class="literal">@Primary</code></h2></div></div></div><p>When using Feign with Hystrix fallbacks, there are multiple beans in the <code class="literal">ApplicationContext</code> of the same type. This will cause <code class="literal">@Autowired</code> to not work because there isn&#8217;t exactly one bean, or one marked as primary. To work around this, Spring Cloud Netflix marks all Feign instances as <code class="literal">@Primary</code>, so Spring Framework will know which bean to inject. In some cases, this may not be desirable. To turn off this behavior set the <code class="literal">primary</code> attribute of <code class="literal">@FeignClient</code> to false.</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@FeignClient(name = "hello", primary = false)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> HelloClient {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// methods here</span>
}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spring-cloud-feign-inheritance" href="#spring-cloud-feign-inheritance"></a>7.7&nbsp;Feign Inheritance Support</h2></div></div></div><p>Feign supports boilerplate apis via single-inheritance interfaces.
This allows grouping common operations into convenient base interfaces.</p><p><b>UserService.java.&nbsp;</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> UserService {

    <em><span class="hl-annotation" style="color: gray">@RequestMapping(method = RequestMethod.GET, value ="/users/{id}")</span></em>
    User getUser(<em><span class="hl-annotation" style="color: gray">@PathVariable("id")</span></em> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">long</span> id);
}</pre><p>
</p><p><b>UserResource.java.&nbsp;</b>
</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RestController</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> UserResource <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">implements</span> UserService {

}</pre><p>
</p><p><b>UserClient.java.&nbsp;</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">package</span> project.user;

<em><span class="hl-annotation" style="color: gray">@FeignClient("users")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> UserClient <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> UserService {

}</pre><p>
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>It is generally not advisable to share an interface between a
server and a client. It introduces tight coupling, and also actually
doesn&#8217;t work with Spring MVC in its current form (method parameter
mapping is not inherited).</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_feign_request_response_compression" href="#_feign_request_response_compression"></a>7.8&nbsp;Feign request/response compression</h2></div></div></div><p>You may consider enabling the request or response GZIP compression for your
Feign requests. You can do this by enabling one of the properties:</p><pre class="programlisting">feign.compression.request.enabled=true
feign.compression.response.enabled=true</pre><p>Feign request compression gives you settings similar to what you may set for your web server:</p><pre class="programlisting">feign.compression.request.enabled=true
feign.compression.request.mime-types=text/xml,application/xml,application/json
feign.compression.request.min-request-size=<span class="hl-number">2048</span></pre><p>These properties allow you to be selective about the compressed media types and minimum request threshold length.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_feign_logging" href="#_feign_logging"></a>7.9&nbsp;Feign logging</h2></div></div></div><p>A logger is created for each Feign client created. By default the name of the logger is the full class name of the interface used to create the Feign client. Feign logging only responds to the <code class="literal">DEBUG</code> level.</p><p><b>application.yml.&nbsp;</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">logging.level.project.user.UserClient</span>: DEBUG</pre><p>
</p><p>The <code class="literal">Logger.Level</code> object that you may configure per client, tells Feign how much to log. Choices are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><code class="literal">NONE</code>, No logging (<span class="strong"><strong>DEFAULT</strong></span>).</li><li class="listitem"><code class="literal">BASIC</code>, Log only the request method and URL and the response status code and execution time.</li><li class="listitem"><code class="literal">HEADERS</code>, Log the basic information along with request and response headers.</li><li class="listitem"><code class="literal">FULL</code>, Log the headers, body, and metadata for both requests and responses.</li></ul></div><p>For example, the following would set the <code class="literal">Logger.Level</code> to <code class="literal">FULL</code>:</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> FooConfiguration {
    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    Logger.Level feignLoggerLevel() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> Logger.Level.FULL;
    }
}</pre></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="_external_configuration_archaius" href="#_external_configuration_archaius"></a>8.&nbsp;External Configuration: Archaius</h1></div></div></div><p><a class="link" href="https://github.com/Netflix/archaius" target="_top">Archaius</a> is the Netflix client side configuration library.  It is the library used by all of the Netflix OSS components for configuration.  Archaius is an extension of the <a class="link" href="https://commons.apache.org/proper/commons-configuration" target="_top">Apache Commons Configuration</a> project.  It allows updates to configuration by either polling a source for changes or for a source to push changes to the client.  Archaius uses Dynamic&lt;Type&gt;Property classes as handles to properties.</p><p><b>Archaius Example.&nbsp;</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> ArchaiusTest {
    DynamicStringProperty myprop = DynamicPropertyFactory
            .getInstance()
            .getStringProperty(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"my.prop"</span>);

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> doSomething() {
        OtherClass.someMethod(myprop.get());
    }
}</pre><p>
</p><p>Archaius has its own set of configuration files and loading priorities.  Spring applications should generally not use Archaius directly, but the need to configure the Netflix tools natively remains.  Spring Cloud has a Spring Environment Bridge so Archaius can read properties from the Spring Environment.  This allows Spring Boot projects to use the normal configuration toolchain, while allowing them to configure the Netflix tools, for the most part, as documented.</p></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="_router_and_filter_zuul" href="#_router_and_filter_zuul"></a>9.&nbsp;Router and Filter: Zuul</h1></div></div></div><p>Routing in an integral part of a microservice architecture.  For example, <code class="literal">/</code> may be mapped to your web application, <code class="literal">/api/users</code> is mapped to the user service and <code class="literal">/api/shop</code> is mapped to the shop service.  <a class="link" href="https://github.com/Netflix/zuul" target="_top">Zuul</a> is a JVM based router and server side load balancer by Netflix.</p><p><a class="link" href="https://www.slideshare.net/MikeyCohen1/edge-architecture-ieee-international-conference-on-cloud-engineering-32240146/27" target="_top">Netflix uses Zuul</a> for the following:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Authentication</li><li class="listitem">Insights</li><li class="listitem">Stress Testing</li><li class="listitem">Canary Testing</li><li class="listitem">Dynamic Routing</li><li class="listitem">Service Migration</li><li class="listitem">Load Shedding</li><li class="listitem">Security</li><li class="listitem">Static Response handling</li><li class="listitem">Active/Active traffic management</li></ul></div><p>Zuul&#8217;s rule engine allows rules and filters to be written in essentially any JVM language, with built in support for Java and Groovy.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>The configuration property <code class="literal">zuul.max.host.connections</code> has been replaced by two new properties, <code class="literal">zuul.host.maxTotalConnections</code> and <code class="literal">zuul.host.maxPerRouteConnections</code> which default to 200 and 20 respectively.</p></td></tr></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Default Hystrix isolation pattern (ExecutionIsolationStrategy) for all routes is SEMAPHORE.  <code class="literal">zuul.ribbonIsolationStrategy</code> can be changed to THREAD if this isolation pattern is preferred.</p></td></tr></table></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="netflix-zuul-starter" href="#netflix-zuul-starter"></a>9.1&nbsp;How to Include Zuul</h2></div></div></div><p>To include Zuul in your project use the starter with group <code class="literal">org.springframework.cloud</code>
and artifact id <code class="literal">spring-cloud-starter-zuul</code>. See the <a class="link" href="https://projects.spring.io/spring-cloud/" target="_top">Spring Cloud Project page</a>
for details on setting up your build system with the current Spring Cloud Release Train.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="netflix-zuul-reverse-proxy" href="#netflix-zuul-reverse-proxy"></a>9.2&nbsp;Embedded Zuul Reverse Proxy</h2></div></div></div><p>Spring Cloud has created an embedded Zuul proxy to ease the
development of a very common use case where a UI application wants to
proxy calls to one or more back end services.  This feature is useful
for a user interface to proxy to the backend services it requires,
avoiding the need to manage CORS and authentication concerns
independently for all the backends.</p><p>To enable it, annotate a Spring Boot main class with
<code class="literal">@EnableZuulProxy</code>, and this forwards local calls to the appropriate
service.  By convention, a service with the ID "users", will
receive requests from the proxy located at <code class="literal">/users</code> (with the prefix
stripped). The proxy uses Ribbon to locate an instance to forward to
via discovery, and all requests are executed in a
<a class="link" href="#hystrix-fallbacks-for-routes" title="9.12&nbsp;Providing Hystrix Fallbacks For Routes">hystrix command</a>, so
failures will show up in Hystrix metrics, and once the circuit is open
the proxy will not try to contact the service.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>the Zuul starter does not include a discovery client, so for
routes based on service IDs you need to provide one of those
on the classpath as well (e.g. Eureka is one choice).</p></td></tr></table></div><p>To skip having a service automatically added, set
<code class="literal">zuul.ignored-services</code> to a list of service id patterns. If a service
matches a pattern that is ignored, but also included in the explicitly
configured routes map, then it will be unignored. Example:</p><p><b>application.yml.&nbsp;</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute"> zuul</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  ignoredServices</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'*'</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    users</span>: /myusers/**</pre><p>
</p><p>In this example, all services are ignored <span class="strong"><strong>except</strong></span> "users".</p><p>To augment or change
the proxy routes, you can add external configuration like the
following:</p><p><b>application.yml.&nbsp;</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute"> zuul</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    users</span>: /myusers/**</pre><p>
</p><p>This means that http calls to "/myusers" get forwarded to the "users"
service (for example "/myusers/101" is forwarded to "/101").</p><p>To get more fine-grained control over a route you can specify the path
and the serviceId independently:</p><p><b>application.yml.&nbsp;</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute"> zuul</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    users</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      path</span>: /myusers/**
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      serviceId</span>: users_service</pre><p>
</p><p>This means that http calls to "/myusers" get forwarded to the
"users_service" service.  The route has to have a "path" which can be
specified as an ant-style pattern, so "/myusers/*" only matches one
level, but "/myusers/**" matches hierarchically.</p><p>The location of the backend can be specified as either a "serviceId"
(for a service from discovery) or a "url" (for a physical location), e.g.</p><p><b>application.yml.&nbsp;</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute"> zuul</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    users</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      path</span>: /myusers/**
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      url</span>: https://example.com/users_service</pre><p>
</p><p>These simple url-routes don&#8217;t get executed as a <code class="literal">HystrixCommand</code> nor can you loadbalance multiple URLs with Ribbon.
To achieve this, specify a service-route and configure a Ribbon client for the
serviceId (this currently requires disabling Eureka support in Ribbon:
see <a class="link" href="#spring-cloud-ribbon-without-eureka" title="6.5&nbsp;Example: How to Use Ribbon Without Eureka">above for more information</a>), e.g.</p><p><b>application.yml.&nbsp;</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">zuul</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    users</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      path</span>: /myusers/**
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      serviceId</span>: users

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">ribbon</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  eureka</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    enabled</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">false</span>

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">users</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  ribbon</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    listOfServers</span>: example.com,google.com</pre><p>
</p><p>You can provide convention between serviceId and routes using
regexmapper.  It uses regular expression named groups to extract
variables from serviceId and inject them into a route pattern.</p><p><b>ApplicationConfiguration.java.&nbsp;</b>
</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> PatternServiceRouteMapper serviceRouteMapper() {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> PatternServiceRouteMapper(
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"(?&lt;name&gt;^.+)-(?&lt;version&gt;v.+$)"</span>,
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"${version}/${name}"</span>);
}</pre><p>
</p><p>This means that a serviceId "myusers-v1" will be mapped to route
"/v1/myusers/**".  Any regular expression is accepted but all named
groups must be present in both servicePattern and routePattern.  If
servicePattern does not match a serviceId, the default behavior is
used. In the example above, a serviceId "myusers" will be mapped to route
"/myusers/**" (no version detected) This feature is disable by
default and only applies to discovered services.</p><p>To add a prefix to all mappings, set <code class="literal">zuul.prefix</code> to a value, such as
<code class="literal">/api</code>. The proxy prefix is stripped from the request before the
request is forwarded by default (switch this behaviour off with
<code class="literal">zuul.stripPrefix=false</code>). You can also switch off the stripping of
the service-specific prefix from individual routes, e.g.</p><p><b>application.yml.&nbsp;</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute"> zuul</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    users</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      path</span>: /myusers/**
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      stripPrefix</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">false</span></pre><p>
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p><code class="literal">zuul.stripPrefix</code> only applies to the prefix set in <code class="literal">zuul.prefix</code>.  It does not have any effect on prefixes
defined within a given route&#8217;s <code class="literal">path</code>.</p></td></tr></table></div><p>In this example, requests to "/myusers/101" will be forwarded to "/myusers/101" on the "users" service.</p><p>The <code class="literal">zuul.routes</code> entries actually bind to an object of type <code class="literal">ZuulProperties</code>. If you
look at the properties of that object you will see that it also has a "retryable" flag.
Set that flag to "true" to have the Ribbon client automatically retry failed requests
(and if you need to you can modify the parameters of the retry operations using
the Ribbon client configuration).</p><p>The <code class="literal">X-Forwarded-Host</code> header is added to the forwarded requests by
default.  To turn it off set <code class="literal">zuul.addProxyHeaders = false</code>.  The
prefix path is stripped by default, and the request to the backend
picks up a header "X-Forwarded-Prefix" ("/myusers" in the examples
above).</p><p>An application with <code class="literal">@EnableZuulProxy</code> could act as a standalone
server if you set a default route ("/"), for example <code class="literal">zuul.route.home:
/</code> would route all traffic (i.e. "/**") to the "home" service.</p><p>If more fine-grained ignoring is needed, you can specify specific patterns to ignore.
These patterns are evaluated at the start of the route location process, which
means prefixes should be included in the pattern to warrant a match. Ignored patterns
span all services and supersede any other route specification.</p><p><b>application.yml.&nbsp;</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute"> zuul</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  ignoredPatterns</span>: /**/admin/**
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    users</span>: /myusers/**</pre><p>
</p><p>This means that all calls such as "/myusers/101" will be forwarded to "/101" on the "users" service.
But calls including "/admin/" will not resolve.</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="images/warning.png"></td><th align="left">Warning</th></tr><tr><td align="left" valign="top"><p>If you need your routes to have their order preserved you need to use a YAML
file as the ordering will be lost using a properties file. For example:</p></td></tr></table></div><p><b>application.yml.&nbsp;</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute"> zuul</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    users</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      path</span>: /myusers/**
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    legacy</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      path</span>: /**</pre><p>
</p><p>If you were to use a properties file, the <code class="literal">legacy</code> path may end up in front of the <code class="literal">users</code>
path rendering the <code class="literal">users</code> path unreachable.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_zuul_http_client" href="#_zuul_http_client"></a>9.3&nbsp;Zuul Http Client</h2></div></div></div><p>The default HTTP client used by zuul is now backed by the Apache HTTP Client instead of the
deprecated Ribbon <code class="literal">RestClient</code>. To use <code class="literal">RestClient</code> or to use the <code class="literal">okhttp3.OkHttpClient</code> set
<code class="literal">ribbon.restclient.enabled=true</code> or <code class="literal">ribbon.okhttp.enabled=true</code> respectively.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_cookies_and_sensitive_headers" href="#_cookies_and_sensitive_headers"></a>9.4&nbsp;Cookies and Sensitive Headers</h2></div></div></div><p>It&#8217;s OK to share headers between services in the same system, but you
probably don&#8217;t want sensitive headers leaking downstream into external
servers. You can specify a list of ignored headers as part of the
route configuration. Cookies play a special role because they have
well-defined semantics in browsers, and they are always to be treated
as sensitive. If the consumer of your proxy is a browser, then cookies
for downstream services also cause problems for the user because they
all get jumbled up (all downstream services look like they come from
the same place).</p><p>If you are careful with the design of your services, for example if
only one of the downstream services sets cookies, then you might be
able to let them flow from the backend all the way up to the
caller. Also, if your proxy sets cookies and all your back end
services are part of the same system, it can be natural to simply
share them (and for instance use Spring Session to link them up to some
shared state). Other than that, any cookies that get set by downstream
services are likely to be not very useful to the caller, so it is
recommended that you make (at least) "Set-Cookie" and "Cookie" into
sensitive headers for routes that are not part of your domain. Even
for routes that <span class="strong"><strong>are</strong></span> part of your domain, try to think carefully
about what it means before allowing cookies to flow between them and
the proxy.</p><p>The sensitive headers can be configured as a comma-separated list per
route, e.g.</p><p><b>application.yml.&nbsp;</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute"> zuul</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    users</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      path</span>: /myusers/**
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      sensitiveHeaders</span>: Cookie,Set-Cookie,Authorization
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      url</span>: https://downstream</pre><p>
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>this is the default value for <code class="literal">sensitiveHeaders</code>, so you don&#8217;t
need to set it unless you want it to be different. N.B. this is new in
Spring Cloud Netflix 1.1 (in 1.0 the user had no control over headers
and all cookies flow in both directions).</p></td></tr></table></div><p>The <code class="literal">sensitiveHeaders</code> are a blacklist and the default is not empty,
so to make Zuul send all headers (except the "ignored" ones) you would
have to explicitly set it to the empty list. This is necessary if you
want to pass cookie or authorization headers to your back end. Example:</p><p><b>application.yml.&nbsp;</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute"> zuul</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    users</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      path</span>: /myusers/**
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      sensitiveHeaders</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      url</span>: https://downstream</pre><p>
</p><p>Sensitive headers can also be set globally by setting <code class="literal">zuul.sensitiveHeaders</code>. If <code class="literal">sensitiveHeaders</code> is set on a route, this will override the global <code class="literal">sensitiveHeaders</code> setting.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_ignored_headers" href="#_ignored_headers"></a>9.5&nbsp;Ignored Headers</h2></div></div></div><p>In addition to the per-route sensitive headers, you can set a global
value for <code class="literal">zuul.ignoredHeaders</code> for values that should be discarded
(both request and response) during interactions with downstream
services. By default these are empty, if Spring Security is not on the
classpath, and otherwise they are initialized to a set of well-known
"security" headers (e.g. involving caching) as specified by Spring
Security. The assumption in this case is that the downstream services
might add these headers too, and we want the values from the proxy.
To not discard these well known security headers in case Spring Security is on the classpath you can set <code class="literal">zuul.ignoreSecurityHeaders</code> to <code class="literal">false</code>. This can be useful if you disabled the HTTP Security response headers in Spring Security and want the values provided by downstream services</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_the_routes_endpoint" href="#_the_routes_endpoint"></a>9.6&nbsp;The Routes Endpoint</h2></div></div></div><p>If you are using <code class="literal">@EnableZuulProxy</code> with tha Spring Boot Actuator you
will enable (by default) an additional endpoint, available via HTTP as
<code class="literal">/routes</code>. A GET to this endpoint will return a list of the mapped
routes. A POST will force a refresh of the existing routes (e.g. in
case there have been changes in the service catalog).  You can disable
this endpoint by setting <code class="literal">endpoints.routes.enabled</code> to <code class="literal">false</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>the routes should respond automatically to changes in the
service catalog, but the POST to /routes is a way to force the change
to happen immediately.</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_strangulation_patterns_and_local_forwards" href="#_strangulation_patterns_and_local_forwards"></a>9.7&nbsp;Strangulation Patterns and Local Forwards</h2></div></div></div><p>A common pattern when migrating an existing application or API is to
"strangle" old endpoints, slowly replacing them with different
implementations. The Zuul proxy is a useful tool for this because you
can use it to handle all traffic from clients of the old endpoints,
but redirect some of the requests to new ones.</p><p>Example configuration:</p><p><b>application.yml.&nbsp;</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute"> zuul</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    first</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      path</span>: /first/**
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      url</span>: https://first.example.com
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    second</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      path</span>: /second/**
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      url</span>: forward:/second
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    third</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      path</span>: /third/**
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      url</span>: forward:/<span class="hl-number">3</span>rd
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    legacy</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      path</span>: /**
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      url</span>: https://legacy.example.com</pre><p>
</p><p>In this example we are strangling the "legacy" app which is mapped to
all requests that do not match one of the other patterns. Paths in
<code class="literal">/first/**</code> have been extracted into a new service with an external
URL. And paths in <code class="literal">/second/**</code> are forwarded so they can be handled
locally, e.g. with a normal Spring <code class="literal">@RequestMapping</code>. Paths in
<code class="literal">/third/**</code> are also forwarded, but with a different prefix
(i.e. <code class="literal">/third/foo</code> is forwarded to <code class="literal">/3rd/foo</code>).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>The ignored patterns aren&#8217;t completely ignored, they just
aren&#8217;t handled by the proxy (so they are also effectively forwarded
locally).</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_uploading_files_through_zuul" href="#_uploading_files_through_zuul"></a>9.8&nbsp;Uploading Files through Zuul</h2></div></div></div><p>If you <code class="literal">@EnableZuulProxy</code> you can use the proxy paths to
upload files and it should just work as long as the files
are small. For large files there is an alternative path
which bypasses the Spring <code class="literal">DispatcherServlet</code> (to
avoid multipart processing) in "/zuul/*". I.e. if
<code class="literal">zuul.routes.customers=/customers/**</code> then you can
POST large files to "/zuul/customers/*". The servlet
path is externalized via <code class="literal">zuul.servletPath</code>. Extremely
large files will also require elevated timeout settings
if the proxy route takes you through a Ribbon load
balancer, e.g.</p><p><b>application.yml.&nbsp;</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds</span>: <span class="hl-number">60000</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">ribbon</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  ConnectTimeout</span>: <span class="hl-number">3000</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  ReadTimeout</span>: <span class="hl-number">60000</span></pre><p>
</p><p>Note that for streaming to work with large files, you need to use chunked encoding in the request (which some browsers
do not do by default). E.g. on the command line:</p><pre class="screen">$ curl -v -H "Transfer-Encoding: chunked" \
    -F "file=@mylarge.iso" localhost:9999/zuul/simple/file</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_query_string_encoding" href="#_query_string_encoding"></a>9.9&nbsp;Query String Encoding</h2></div></div></div><p>When processing the incoming request, query params are decoded so they can be available for possible modifications in
Zuul filters. They are then re-encoded when building the backend request in the route filters. The result
can be different than the original input if it was encoded using Javascript&#8217;s <code class="literal">encodeURIComponent()</code> method for example.
While this causes no issues in most cases, some web servers can be picky with the encoding of complex query string.</p><p>To force the original encoding of the query string, it is possible to pass a special flag to <code class="literal">ZuulProperties</code> so
that the query string is taken as is with the <code class="literal">HttpServletRequest::getQueryString</code> method :</p><p><b>application.yml.&nbsp;</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute"> zuul</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  forceOriginalQueryStringEncoding</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span></pre><p>
</p><p><span class="strong"><strong>Note:</strong></span> This special flag only works with <code class="literal">SimpleHostRoutingFilter</code> and you loose the ability to easily override
query parameters with <code class="literal">RequestContext.getCurrentContext().setRequestQueryParams(someOverriddenParameters)</code> since
the query string is now fetched directly on the original <code class="literal">HttpServletRequest</code>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_plain_embedded_zuul" href="#_plain_embedded_zuul"></a>9.10&nbsp;Plain Embedded Zuul</h2></div></div></div><p>You can also run a Zuul server without the proxying, or switch on parts of the proxying platform selectively, if you
use <code class="literal">@EnableZuulServer</code> (instead of <code class="literal">@EnableZuulProxy</code>). Any beans that you add to the application of type <code class="literal">ZuulFilter</code>
will be installed automatically, as they are with <code class="literal">@EnableZuulProxy</code>, but without any of the proxy filters being added
automatically.</p><p>In this case the routes into the Zuul server are still specified by
configuring "zuul.routes.*", but there is no service
discovery and no proxying, so the "serviceId" and "url" settings are
ignored. For example:</p><p><b>application.yml.&nbsp;</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute"> zuul</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    api</span>: /api/**</pre><p>
</p><p>maps all paths in "/api/**" to the Zuul filter chain.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_disable_zuul_filters" href="#_disable_zuul_filters"></a>9.11&nbsp;Disable Zuul Filters</h2></div></div></div><p>Zuul for Spring Cloud comes with a number of <code class="literal">ZuulFilter</code> beans enabled by default
in both proxy and server mode.  See <a class="link" href="https://github.com/spring-cloud/spring-cloud-netflix/tree/master/spring-cloud-netflix-core/src/main/java/org/springframework/cloud/netflix/zuul/filters" target="_top">the zuul filters package</a> for the
possible filters that are enabled.  If you want to disable one, simply set
<code class="literal">zuul.&lt;SimpleClassName&gt;.&lt;filterType&gt;.disable=true</code>. By convention, the package after
<code class="literal">filters</code> is the Zuul filter type. For example to disable
<code class="literal">org.springframework.cloud.netflix.zuul.filters.post.SendResponseFilter</code> set
<code class="literal">zuul.SendResponseFilter.post.disable=true</code>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="hystrix-fallbacks-for-routes" href="#hystrix-fallbacks-for-routes"></a>9.12&nbsp;Providing Hystrix Fallbacks For Routes</h2></div></div></div><p>When a circuit for a given route in Zuul is tripped you can provide a fallback response
by creating a bean of type <code class="literal">ZuulFallbackProvider</code>.  Within this bean you need to specify
the route ID the fallback is for and provide a <code class="literal">ClientHttpResponse</code> to return
as a fallback.  Here is a very simple <code class="literal">ZuulFallbackProvider</code> implementation.</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MyFallbackProvider <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">implements</span> ZuulFallbackProvider {
    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String getRoute() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"customers"</span>;
    }

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> ClientHttpResponse fallbackResponse() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> ClientHttpResponse() {
            <em><span class="hl-annotation" style="color: gray">@Override</span></em>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> HttpStatus getStatusCode() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> IOException {
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> HttpStatus.OK;
            }

            <em><span class="hl-annotation" style="color: gray">@Override</span></em>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">int</span> getRawStatusCode() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> IOException {
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span class="hl-number">200</span>;
            }

            <em><span class="hl-annotation" style="color: gray">@Override</span></em>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String getStatusText() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> IOException {
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"OK"</span>;
            }

            <em><span class="hl-annotation" style="color: gray">@Override</span></em>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> close() {

            }

            <em><span class="hl-annotation" style="color: gray">@Override</span></em>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> InputStream getBody() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> IOException {
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> ByteArrayInputStream(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"fallback"</span>.getBytes());
            }

            <em><span class="hl-annotation" style="color: gray">@Override</span></em>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> HttpHeaders getHeaders() {
                HttpHeaders headers = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> HttpHeaders();
                headers.setContentType(MediaType.APPLICATION_JSON);
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> headers;
            }
        };
    }
}</pre><p>And here is what the route configuration would look like.</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">zuul</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    customers</span>: /customers/**</pre><p>If you would like to provide a default fallback for all routes than you can create a bean of
type <code class="literal">ZuulFallbackProvider</code> and have the <code class="literal">getRoute</code> method return <code class="literal">*</code> or <code class="literal">null</code>.</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MyFallbackProvider <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">implements</span> ZuulFallbackProvider {
    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String getRoute() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"*"</span>;
    }

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> ClientHttpResponse fallbackResponse() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> ClientHttpResponse() {
            <em><span class="hl-annotation" style="color: gray">@Override</span></em>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> HttpStatus getStatusCode() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> IOException {
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> HttpStatus.OK;
            }

            <em><span class="hl-annotation" style="color: gray">@Override</span></em>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">int</span> getRawStatusCode() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> IOException {
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span class="hl-number">200</span>;
            }

            <em><span class="hl-annotation" style="color: gray">@Override</span></em>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String getStatusText() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> IOException {
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"OK"</span>;
            }

            <em><span class="hl-annotation" style="color: gray">@Override</span></em>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> close() {

            }

            <em><span class="hl-annotation" style="color: gray">@Override</span></em>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> InputStream getBody() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> IOException {
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> ByteArrayInputStream(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"fallback"</span>.getBytes());
            }

            <em><span class="hl-annotation" style="color: gray">@Override</span></em>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> HttpHeaders getHeaders() {
                HttpHeaders headers = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> HttpHeaders();
                headers.setContentType(MediaType.APPLICATION_JSON);
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> headers;
            }
        };
    }
}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="zuul-developer-guide" href="#zuul-developer-guide"></a>9.13&nbsp;Zuul Developer Guide</h2></div></div></div><p>For a general overview of how Zuul works, please see <a class="link" href="https://github.com/Netflix/zuul/wiki/How-it-Works" target="_top">the Zuul Wiki</a>.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_the_zuul_servlet" href="#_the_zuul_servlet"></a>9.13.1&nbsp;The Zuul Servlet</h3></div></div></div><p>Zuul is implemented as a Servlet. For the general cases, Zuul is embedded into the Spring Dispatch mechanism. This allows Spring MVC to be in control of the routing. In this case, Zuul is configured to buffer requests. If there is a need to go through Zuul without buffering requests (e.g. for large file uploads), the Servlet is also installed outside of the Spring Dispatcher. By default, this is located at <code class="literal">/zuul</code>. This path can be changed with the <code class="literal">zuul.servlet-path</code> property.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_zuul_requestcontext" href="#_zuul_requestcontext"></a>9.13.2&nbsp;Zuul RequestContext</h3></div></div></div><p>To pass information between filters, Zuul uses a <a class="link" href="https://github.com/Netflix/zuul/blob/1.x/zuul-core/src/main/java/com/netflix/zuul/context/RequestContext.java" target="_top"><code class="literal">RequestContext</code></a>. Its data is held in a <code class="literal">ThreadLocal</code> specific to each request. Information about where to route requests, errors and the actual <code class="literal">HttpServletRequest</code> and <code class="literal">HttpServletResponse</code> are stored there. The <code class="literal">RequestContext</code> extends <code class="literal">ConcurrentHashMap</code>, so anything can be stored in the context. <a class="link" href="https://github.com/spring-cloud/spring-cloud-netflix/blob/master/spring-cloud-netflix-core/src/main/java/org/springframework/cloud/netflix/zuul/filters/support/FilterConstants.java" target="_top"><code class="literal">FilterConstants</code></a> contains the keys that are used by the filters installed by Spring Cloud Netflix (more on these later).</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="__literal_enablezuulproxy_literal_vs_literal_enablezuulserver_literal" href="#__literal_enablezuulproxy_literal_vs_literal_enablezuulserver_literal"></a>9.13.3&nbsp;<code class="literal">@EnableZuulProxy</code> vs. <code class="literal">@EnableZuulServer</code></h3></div></div></div><p>Spring Cloud Netflix installs a number of filters based on which annotation was used to enable Zuul. <code class="literal">@EnableZuulProxy</code> is a superset of <code class="literal">@EnableZuulServer</code>. In other words, <code class="literal">@EnableZuulProxy</code> contains all filters installed by <code class="literal">@EnableZuulServer</code>. The additional filters in the "proxy" enable routing functionality. If you want a "blank" Zuul, you should use <code class="literal">@EnableZuulServer</code>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="__literal_enablezuulserver_literal_filters" href="#__literal_enablezuulserver_literal_filters"></a>9.13.4&nbsp;<code class="literal">@EnableZuulServer</code> Filters</h3></div></div></div><p>Creates a <code class="literal">SimpleRouteLocator</code> that loads route definitions from Spring Boot configuration files.</p><p>The following filters are installed (as normal Spring Beans):</p><p>Pre filters:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><code class="literal">ServletDetectionFilter</code>: Detects if the request is through the Spring Dispatcher. Sets boolean with key <code class="literal">FilterConstants.IS_DISPATCHER_SERVLET_REQUEST_KEY</code>.</li><li class="listitem"><code class="literal">FormBodyWrapperFilter</code>: Parses form data and reencodes it for downstream requests.</li><li class="listitem"><code class="literal">DebugFilter</code>: if the <code class="literal">debug</code> request parameter is set, this filter sets <code class="literal">RequestContext.setDebugRouting()</code> and <code class="literal">RequestContext.setDebugRequest()</code> to true.</li></ul></div><p>Route filters:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><code class="literal">SendForwardFilter</code>: This filter forwards requests using the Servlet <code class="literal">RequestDispatcher</code>. The forwarding location is stored in the <code class="literal">RequestContext</code> attribute <code class="literal">FilterConstants.FORWARD_TO_KEY</code>. This is useful for forwarding to endpoints in the current application.</li></ul></div><p>Post filters:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><code class="literal">SendResponseFilter</code>: Writes responses from proxied requests to the current response.</li></ul></div><p>Error filters:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><code class="literal">SendErrorFilter</code>: Forwards to /error (by default) if <code class="literal">RequestContext.getThrowable()</code> is not null. The default forwarding path (<code class="literal">/error</code>) can be changed by setting the <code class="literal">error.path</code> property.</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="__literal_enablezuulproxy_literal_filters" href="#__literal_enablezuulproxy_literal_filters"></a>9.13.5&nbsp;<code class="literal">@EnableZuulProxy</code> Filters</h3></div></div></div><p>Creates a <code class="literal">DiscoveryClientRouteLocator</code> that loads route definitions from a <code class="literal">DiscoveryClient</code> (like Eureka), as well as from properties. A route is created for each <code class="literal">serviceId</code> from the <code class="literal">DiscoveryClient</code>. As new services are added, the routes will be refreshed.</p><p>In addition to the filters described above, the following filters are installed (as normal Spring Beans):</p><p>Pre filters:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><code class="literal">PreDecorationFilter</code>: This filter determines where and how to route based on the supplied <code class="literal">RouteLocator</code>. It also sets various proxy-related headers for downstream requests.</li></ul></div><p>Route filters:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p class="simpara"><code class="literal">RibbonRoutingFilter</code>: This filter uses Ribbon, Hystrix and pluggable HTTP clients to send requests. Service ids are found in the <code class="literal">RequestContext</code> attribute <code class="literal">FilterConstants.SERVICE_ID_KEY</code>. This filter can use different HTTP clients. They are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">Apache <code class="literal">HttpClient</code>. This is the default client.</li><li class="listitem">Squareup <code class="literal">OkHttpClient</code> v3. This is enabled by having the <code class="literal">com.squareup.okhttp3:okhttp</code> library on the classpath and setting <code class="literal">ribbon.okhttp.enabled=true</code>.</li><li class="listitem">Netflix Ribbon HTTP client. This is enabled by setting <code class="literal">ribbon.restclient.enabled=true</code>. This client has limitations, such as it doesn&#8217;t support the PATCH method, but also has built-in retry.</li></ul></div></li><li class="listitem"><code class="literal">SimpleHostRoutingFilter</code>: This filter sends requests to predetermined URLs via an Apache HttpClient. URLs are found in <code class="literal">RequestContext.getRouteHost()</code>.</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_custom_zuul_filter_examples" href="#_custom_zuul_filter_examples"></a>9.13.6&nbsp;Custom Zuul Filter examples</h3></div></div></div><p>Most of the following "How to Write" examples below are included <a class="link" href="https://github.com/spring-cloud-samples/sample-zuul-filters" target="_top">Sample Zuul Filters</a> project. There are also examples of manipulating the request or response body in that repository.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_how_to_write_a_pre_filter" href="#_how_to_write_a_pre_filter"></a>9.13.7&nbsp;How to Write a Pre Filter</h3></div></div></div><p>Pre filters are used to set up data in the <code class="literal">RequestContext</code> for use in filters downstream. The main use case is to set information required for route filters.</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> QueryParamPreFilter <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> ZuulFilter {
	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">int</span> filterOrder() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> PRE_DECORATION_FILTER_ORDER - <span class="hl-number">1</span>; <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// run before PreDecoration</span>
	}

	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String filterType() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> PRE_TYPE;
	}

	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">boolean</span> shouldFilter() {
		RequestContext ctx = RequestContext.getCurrentContext();
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> !ctx.containsKey(FORWARD_TO_KEY) <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// a filter has already forwarded</span>
				&amp;&amp; !ctx.containsKey(SERVICE_ID_KEY); <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// a filter has already determined serviceId</span>
	}
    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Object run() {
        RequestContext ctx = RequestContext.getCurrentContext();
		HttpServletRequest request = ctx.getRequest();
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">if</span> (request.getParameter(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo"</span>) != null) {
		    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// put the serviceId in `RequestContext`</span>
    		ctx.put(SERVICE_ID_KEY, request.getParameter(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo"</span>));
    	}
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> null;
    }
}</pre><p>The filter above populates <code class="literal">SERVICE_ID_KEY</code> from the <code class="literal">foo</code> request parameter. In reality, it&#8217;s not a good idea to do that kind of direct mapping, but the service id should be looked up from the value of <code class="literal">foo</code> instead.</p><p>Now that <code class="literal">SERVICE_ID_KEY</code> is populated, <code class="literal">PreDecorationFilter</code> won&#8217;t run and <code class="literal">RibbonRoutingFilter</code> will. If you wanted to route to a full URL instead, call <code class="literal">ctx.setRouteHost(url)</code> instead.</p><p>To modify the path that routing filters will forward to, set the <code class="literal">REQUEST_URI_KEY</code>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_how_to_write_a_route_filter" href="#_how_to_write_a_route_filter"></a>9.13.8&nbsp;How to Write a Route Filter</h3></div></div></div><p>Route filters are run after pre filters and are used to make requests to other services. Much of the work here is to translate request and response data to and from the client required model.</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> OkHttpRoutingFilter <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> ZuulFilter {
	<em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> ProxyRequestHelper helper;

	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String filterType() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> ROUTE_TYPE;
	}

	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">int</span> filterOrder() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> SIMPLE_HOST_ROUTING_FILTER_ORDER - <span class="hl-number">1</span>;
	}

	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">boolean</span> shouldFilter() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> RequestContext.getCurrentContext().getRouteHost() != null
				&amp;&amp; RequestContext.getCurrentContext().sendZuulResponse();
	}

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Object run() {
		OkHttpClient httpClient = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> OkHttpClient.Builder()
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// customize</span>
				.build();

		RequestContext context = RequestContext.getCurrentContext();
		HttpServletRequest request = context.getRequest();

		String method = request.getMethod();

		String uri = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.helper.buildZuulRequestURI(request);

		Headers.Builder headers = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Headers.Builder();
		Enumeration&lt;String&gt; headerNames = request.getHeaderNames();
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">while</span> (headerNames.hasMoreElements()) {
			String name = headerNames.nextElement();
			Enumeration&lt;String&gt; values = request.getHeaders(name);

			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">while</span> (values.hasMoreElements()) {
				String value = values.nextElement();
				headers.add(name, value);
			}
		}

		InputStream inputStream = request.getInputStream();

		RequestBody requestBody = null;
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">if</span> (inputStream != null &amp;&amp; HttpMethod.permitsRequestBody(method)) {
			MediaType mediaType = null;
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">if</span> (headers.get(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Content-Type"</span>) != null) {
				mediaType = MediaType.parse(headers.get(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Content-Type"</span>));
			}
			requestBody = RequestBody.create(mediaType, StreamUtils.copyToByteArray(inputStream));
		}

		Request.Builder builder = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Request.Builder()
				.headers(headers.build())
				.url(uri)
				.method(method, requestBody);

		Response response = httpClient.newCall(builder.build()).execute();

		LinkedMultiValueMap&lt;String, String&gt; responseHeaders = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> LinkedMultiValueMap&lt;&gt;();

		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">for</span> (Map.Entry&lt;String, List&lt;String&gt;&gt; entry : response.headers().toMultimap().entrySet()) {
			responseHeaders.put(entry.getKey(), entry.getValue());
		}

		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.helper.setResponse(response.code(), response.body().byteStream(),
				responseHeaders);
		context.setRouteHost(null); <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// prevent SimpleHostRoutingFilter from running</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> null;
    }
}</pre><p>The above filter translates Servlet request information into OkHttp3 request information, executes an HTTP request, then translates OkHttp3 reponse information to the Servlet response. WARNING: this filter might have bugs and not function correctly.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_how_to_write_a_post_filter" href="#_how_to_write_a_post_filter"></a>9.13.9&nbsp;How to Write a Post Filter</h3></div></div></div><p>Post filters typically manipulate the response. In the filter below, we add a random <code class="literal">UUID</code> as the <code class="literal">X-Foo</code> header. Other manipulations, such as transforming the response body, are much more complex and compute-intensive.</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> AddResponseHeaderFilter <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> ZuulFilter {
	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String filterType() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> POST_TYPE;
	}

	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">int</span> filterOrder() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> SEND_RESPONSE_FILTER_ORDER - <span class="hl-number">1</span>;
	}

	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">boolean</span> shouldFilter() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> true;
	}

	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Object run() {
		RequestContext context = RequestContext.getCurrentContext();
    	HttpServletResponse servletResponse = context.getResponse();
		servletResponse.addHeader(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"X-Foo"</span>, UUID.randomUUID().toString());
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> null;
	}
}</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_how_zuul_errors_work" href="#_how_zuul_errors_work"></a>9.13.10&nbsp;How Zuul Errors Work</h3></div></div></div><p>If an exception is thrown during any portion of the Zuul filter lifecycle, the error filters are executed. The <code class="literal">SendErrorFilter</code> is only run if <code class="literal">RequestContext.getThrowable()</code> is not <code class="literal">null</code>. It then sets specific <code class="literal">javax.servlet.error.*</code> attributes in the request and forwards the request to the Spring Boot error page.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_zuul_eager_application_context_loading" href="#_zuul_eager_application_context_loading"></a>9.13.11&nbsp;Zuul Eager Application Context Loading</h3></div></div></div><p>Zuul internally uses Ribbon for calling the remote url&#8217;s and Ribbon clients are by default lazily loaded up by Spring Cloud on first call.
This behavior can be changed for Zuul using the following configuration and will result in the child Ribbon related Application contexts being eagerly loaded up at application startup time.</p><p><b>application.yml.&nbsp;</b>
</p><pre class="screen">zuul:
  ribbon:
    eager-load:
      enabled: true</pre><p>
</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="_polyglot_support_with_sidecar" href="#_polyglot_support_with_sidecar"></a>10.&nbsp;Polyglot support with Sidecar</h1></div></div></div><p>Do you have non-jvm languages you want to take advantage of Eureka, Ribbon and
Config Server?  The Spring Cloud Netflix Sidecar was inspired by
<a class="link" href="https://github.com/Netflix/Prana" target="_top">Netflix Prana</a>.  It includes a simple http api
to get all of the instances (ie host and port) for a given service.  You can
also proxy service calls through an embedded Zuul proxy which gets its route
entries from Eureka.  The Spring Cloud Config Server can be accessed directly
via host lookup or through the Zuul Proxy.  The non-jvm app should implement
a health check so the Sidecar can report to eureka if the app is up or down.</p><p>To include Sidecar in your project use the dependency with group <code class="literal">org.springframework.cloud</code>
and artifact id <code class="literal">spring-cloud-netflix-sidecar</code>.</p><p>To enable the Sidecar, create a Spring Boot application with <code class="literal">@EnableSidecar</code>.
This annotation includes <code class="literal">@EnableCircuitBreaker</code>, <code class="literal">@EnableDiscoveryClient</code>,
and <code class="literal">@EnableZuulProxy</code>.  Run the resulting application on the same host as the
non-jvm application.</p><p>To configure the side car add <code class="literal">sidecar.port</code> and <code class="literal">sidecar.health-uri</code> to <code class="literal">application.yml</code>.
The <code class="literal">sidecar.port</code> property is the port the non-jvm app is listening on.  This
is so the Sidecar can properly register the app with Eureka.  The <code class="literal">sidecar.health-uri</code>
is a uri accessible on the non-jvm app that mimicks a Spring Boot health
indicator.  It should return a json document like the following:</p><p><b>health-uri-document.&nbsp;</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"status"</span>:<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"UP"</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span></pre><p>
</p><p>Here is an example application.yml for a Sidecar application:</p><p><b>application.yml.&nbsp;</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">server</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  port</span>: <span class="hl-number">5678</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  application</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    name</span>: sidecar

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">sidecar</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  port</span>: <span class="hl-number">8000</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  health-uri</span>: http://localhost:<span class="hl-number">8000</span>/health.json</pre><p>
</p><p>The api for the <code class="literal">DiscoveryClient.getInstances()</code> method is <code class="literal">/hosts/{serviceId}</code>.
Here is an example response for <code class="literal">/hosts/customers</code> that returns two instances on
different hosts.  This api is accessible to the non-jvm app (if the sidecar is
on port 5678) at <code class="literal"><a class="link" href="http://localhost:5678/hosts/{serviceId}" target="_top">http://localhost:5678/hosts/{serviceId}</a></code>.</p><p><b>/hosts/customers.&nbsp;</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">[</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"host"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"myhost"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"port"</span>: <span class="hl-number">9000</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"uri"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"http://myhost:9000"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"serviceId"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"CUSTOMERS"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"secure"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">false</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"host"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"myhost2"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"port"</span>: <span class="hl-number">9000</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"uri"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"http://myhost2:9000"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"serviceId"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"CUSTOMERS"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"secure"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">false</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">]</span></pre><p>
</p><p>The Zuul proxy automatically adds routes for each service known in eureka to
<code class="literal">/&lt;serviceId&gt;</code>, so the customers service is available at <code class="literal">/customers</code>.  The
Non-jvm app can access the customer service via <code class="literal"><a class="link" href="http://localhost:5678/customers" target="_top">http://localhost:5678/customers</a></code>
(assuming the sidecar is listening on port 5678).</p><p>If the Config Server is registered with Eureka, non-jvm application can access
it via the Zuul proxy.  If the serviceId of the ConfigServer is <code class="literal">configserver</code>
and the Sidecar is on port 5678, then it can be accessed at
<a class="link" href="http://localhost:5678/configserver" target="_top">http://localhost:5678/configserver</a></p><p>Non-jvm app can take advantage of the Config Server&#8217;s ability to return YAML
documents.  For example, a call to <a class="link" href="https://sidecar.local.spring.io:5678/configserver/default-master.yml" target="_top">https://sidecar.local.spring.io:5678/configserver/default-master.yml</a>
might result in a YAML document like the following</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">eureka</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  client</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    serviceUrl</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      defaultZone</span>: http://localhost:<span class="hl-number">8761</span>/eureka/
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  password</span>: password
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">info</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  description</span>: Spring Cloud Samples
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  url</span>: https://github.com/spring-cloud-samples</pre></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="netflix-rxjava-springmvc" href="#netflix-rxjava-springmvc"></a>11.&nbsp;RxJava with Spring MVC</h1></div></div></div><p>Spring Cloud Netflix includes <a class="link" href="https://github.com/ReactiveX/RxJava" target="_top">RxJava</a>.</p><div class="blockquote"><blockquote class="blockquote"><p>RxJava is a Java VM implementation of <a class="link" href="http://reactivex.io/" target="_top">Reactive Extensions</a>: a library for composing asynchronous and event-based programs by using observable sequences.</p></blockquote></div><p>Spring Cloud Netflix provides support for returning <code class="literal">rx.Single</code> objects from Spring MVC Controllers. It also supports using <code class="literal">rx.Observable</code> objects for <a class="link" href="https://en.wikipedia.org/wiki/Server-sent_events" target="_top">Server-sent events (SSE)</a>. This can be very convenient if your internal APIs are already built using RxJava (see <a class="xref" href="#spring-cloud-feign-hystrix" title="7.4&nbsp;Feign Hystrix Support">Section&nbsp;7.4, &#8220;Feign Hystrix Support&#8221;</a> for examples).</p><p>Here are some examples of using <code class="literal">rx.Single</code>:</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RequestMapping(method = RequestMethod.GET, value = "/single")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Single&lt;String&gt; single() {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> Single.just(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"single value"</span>);
}

<em><span class="hl-annotation" style="color: gray">@RequestMapping(method = RequestMethod.GET, value = "/singleWithResponse")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> ResponseEntity&lt;Single&lt;String&gt;&gt; singleWithResponse() {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> ResponseEntity&lt;&gt;(Single.just(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"single value"</span>),
			HttpStatus.NOT_FOUND);
}

<em><span class="hl-annotation" style="color: gray">@RequestMapping(method = RequestMethod.GET, value = "/singleCreatedWithResponse")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Single&lt;ResponseEntity&lt;String&gt;&gt; singleOuterWithResponse() {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> Single.just(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> ResponseEntity&lt;&gt;(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"single value"</span>, HttpStatus.CREATED));
}

<em><span class="hl-annotation" style="color: gray">@RequestMapping(method = RequestMethod.GET, value = "/throw")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Single&lt;Object&gt; error() {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> Single.error(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> RuntimeException(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Unexpected"</span>));
}</pre><p>If you have an <code class="literal">Observable</code>, rather than a single, you can use <code class="literal">.toSingle()</code> or <code class="literal">.toList().toSingle()</code>. Here are some examples:</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RequestMapping(method = RequestMethod.GET, value = "/single")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Single&lt;String&gt; single() {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> Observable.just(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"single value"</span>).toSingle();
}

<em><span class="hl-annotation" style="color: gray">@RequestMapping(method = RequestMethod.GET, value = "/multiple")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Single&lt;List&lt;String&gt;&gt; multiple() {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> Observable.just(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"multiple"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"values"</span>).toList().toSingle();
}

<em><span class="hl-annotation" style="color: gray">@RequestMapping(method = RequestMethod.GET, value = "/responseWithObservable")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> ResponseEntity&lt;Single&lt;String&gt;&gt; responseWithObservable() {

    Observable&lt;String&gt; observable = Observable.just(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"single value"</span>);
    HttpHeaders headers = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> HttpHeaders();
    headers.setContentType(APPLICATION_JSON_UTF8);
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> ResponseEntity&lt;&gt;(observable.toSingle(), headers, HttpStatus.CREATED);
}

<em><span class="hl-annotation" style="color: gray">@RequestMapping(method = RequestMethod.GET, value = "/timeout")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Observable&lt;String&gt; timeout() {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> Observable.timer(<span class="hl-number">1</span>, TimeUnit.MINUTES).map(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Func1&lt;Long, String&gt;() {
        <em><span class="hl-annotation" style="color: gray">@Override</span></em>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String call(Long aLong) {
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"single value"</span>;
        }
    });
}</pre><p>If you have a streaming endpoint and client, SSE could be an option. To convert <code class="literal">rx.Observable</code> to a Spring <code class="literal">SseEmitter</code> use <code class="literal">RxResponse.sse()</code>. Here are some examples:</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RequestMapping(method = RequestMethod.GET, value = "/sse")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> SseEmitter single() {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> RxResponse.sse(Observable.just(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"single value"</span>));
}

<em><span class="hl-annotation" style="color: gray">@RequestMapping(method = RequestMethod.GET, value = "/messages")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> SseEmitter messages() {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> RxResponse.sse(Observable.just(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"message 1"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"message 2"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"message 3"</span>));
}

<em><span class="hl-annotation" style="color: gray">@RequestMapping(method = RequestMethod.GET, value = "/events")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> SseEmitter event() {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> RxResponse.sse(APPLICATION_JSON_UTF8,
			Observable.just(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> EventDto(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Spring io"</span>, getDate(<span class="hl-number">2016</span>, <span class="hl-number">5</span>, <span class="hl-number">19</span>)),
					<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> EventDto(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"SpringOnePlatform"</span>, getDate(<span class="hl-number">2016</span>, <span class="hl-number">8</span>, <span class="hl-number">1</span>))));
}</pre></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="netflix-metrics" href="#netflix-metrics"></a>12.&nbsp;Metrics: Spectator, Servo, and Atlas</h1></div></div></div><p>When used together, Spectator/Servo and Atlas provide a near real-time operational insight platform.</p><p>Spectator and Servo are Netflix&#8217;s metrics collection libraries. Atlas is a Netflix metrics backend to manage dimensional time series data.</p><p>Servo served Netflix for several years and is still usable, but is gradually being phased out in favor of Spectator, which is only designed to work with Java 8.  Spring Cloud Netflix provides support for both, but Java 8 based applications are encouraged to use Spectator.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_dimensional_vs_hierarchical_metrics" href="#_dimensional_vs_hierarchical_metrics"></a>12.1&nbsp;Dimensional vs. Hierarchical Metrics</h2></div></div></div><p>Spring Boot Actuator metrics are hierarchical and metrics are separated only by name. These names often follow a naming convention that embeds key/value attribute pairs (dimensions) into the name separated by periods. Consider the following metrics for two endpoints, root and star-star:</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"counter.status.200.root"</span>: <span class="hl-number">20</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"counter.status.400.root"</span>: <span class="hl-number">3</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"counter.status.200.star-star"</span>: <span class="hl-number">5</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span></pre><p>The first metric gives us a normalized count of successful requests against the root endpoint per unit of time. But what if the system had 20 endpoints and you want to get a count of successful requests against all the endpoints? Some hierarchical metrics backends would allow you to specify a wild card such as <code class="literal">counter.status.200.*</code> that would read all 20 metrics and aggregate the results. Alternatively, you could provide a <code class="literal">HandlerInterceptorAdapter</code> that intercepts and records a metric like <code class="literal">counter.status.200.all</code> for all successful requests irrespective of the endpoint, but now you must write 20+1 different metrics. Similarly if you want to know the total number of successful requests for all endpoints in the service, you could specify a wild card such as <code class="literal">counter.status.2*.*</code>.</p><p>Even in the presence of wildcarding support on a hierarchical metrics backend, naming consistency can be difficult. Specifically the position of these tags in the name string can slip with time, breaking queries. For example, suppose we add an additional dimension to the hierarchical metrics above for HTTP method. Then <code class="literal">counter.status.200.root</code> becomes <code class="literal">counter.status.200.method.get.root</code>, etc. Our <code class="literal">counter.status.200.*</code> suddenly no longer has the same semantic meaning.  Furthermore, if the new dimension is not applied uniformly across the codebase, certain queries may become impossible. This can quickly get out of hand.</p><p>Netflix metrics are tagged (a.k.a. dimensional). Each metric has a name, but this single named metric can contain multiple statistics and 'tag' key/value pairs that allows more querying flexibility. In fact, the statistics themselves are recorded in a special tag.</p><p>Recorded with Netflix Servo or Spectator, a timer for the root endpoint described above contains 4 statistics per status code, where the count statistic is identical to Spring Boot Actuator&#8217;s counter. In the event that we have encountered an HTTP 200 and 400 thus far, there will be 8 available data points:</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"root(status=200,stastic=count)"</span>: <span class="hl-number">20</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"root(status=200,stastic=max)"</span>: <span class="hl-number">0.7265630630000001</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"root(status=200,stastic=totalOfSquares)"</span>: <span class="hl-number">0.04759702862580789</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"root(status=200,stastic=totalTime)"</span>: <span class="hl-number">0.2093076914666667</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"root(status=400,stastic=count)"</span>: <span class="hl-number">1</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"root(status=400,stastic=max)"</span>: <span class="hl-number">0</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"root(status=400,stastic=totalOfSquares)"</span>: <span class="hl-number">0</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"root(status=400,stastic=totalTime)"</span>: <span class="hl-number">0</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span></pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_default_metrics_collection" href="#_default_metrics_collection"></a>12.2&nbsp;Default Metrics Collection</h2></div></div></div><p>Without any additional dependencies or configuration, a Spring Cloud based service will autoconfigure a Servo <code class="literal">MonitorRegistry</code> and begin collecting metrics on every Spring MVC request. By default, a Servo timer with the name <code class="literal">rest</code> will be recorded for each MVC request which is tagged with:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">HTTP method</li><li class="listitem">HTTP status (e.g. 200, 400, 500)</li><li class="listitem">URI (or "root" if the URI is empty), sanitized for Atlas</li><li class="listitem">The exception class name, if the request handler threw an exception</li><li class="listitem">The caller, if a request header with a key matching <code class="literal">netflix.metrics.rest.callerHeader</code> is set on the request. There is no default key for <code class="literal">netflix.metrics.rest.callerHeader</code>. You must add it to your application properties if you wish to collect caller information.</li></ol></div><p>Set the <code class="literal">netflix.metrics.rest.metricName</code> property to change the name of the metric from <code class="literal">rest</code> to a name you provide.</p><p>If Spring AOP is enabled and <code class="literal">org.aspectj:aspectjweaver</code> is present on your runtime classpath, Spring Cloud will also collect metrics on every client call made with <code class="literal">RestTemplate</code>. A Servo timer with the name of <code class="literal">restclient</code> will be recorded for each MVC request which is tagged with:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">HTTP method</li><li class="listitem">HTTP status (e.g. 200, 400, 500), "CLIENT_ERROR" if the response returned null, or "IO_ERROR" if an <code class="literal">IOException</code> occurred during the execution of the <code class="literal">RestTemplate</code> method</li><li class="listitem">URI, sanitized for Atlas</li><li class="listitem">Client name</li></ol></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="images/warning.png"></td><th align="left">Warning</th></tr><tr><td align="left" valign="top"><p>Avoid using hardcoded url parameters within <code class="literal">RestTemplate</code>.  When targeting dynamic endpoints use URL variables. This will avoid potential "GC Overhead Limit Reached" issues where <code class="literal">ServoMonitorCache</code> treats each url as a unique key.</p></td></tr></table></div><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// recommended</span>
String orderid = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"1"</span>;
restTemplate.getForObject(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"http://testclient/orders/{orderid}"</span>, String.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, orderid)

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// avoid</span>
restTemplate.getForObject(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"http://testclient/orders/1"</span>, String.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>)</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="netflix-metrics-spectator" href="#netflix-metrics-spectator"></a>12.3&nbsp;Metrics Collection: Spectator</h2></div></div></div><p>To enable Spectator metrics, include a dependency on <code class="literal">spring-boot-starter-spectator</code>:</p><pre class="programlisting">    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-starter-spectator<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p>In Spectator parlance, a meter is a named, typed, and tagged configuration and a metric represents the value of a given meter at a point in time. Spectator meters are created and controlled by a registry, which currently has several different implementations. Spectator provides 4 meter types: counter, timer, gauge, and distribution summary.</p><p>Spring Cloud Spectator integration configures an injectable <code class="literal">com.netflix.spectator.api.Registry</code> instance for you. Specifically, it configures a <code class="literal">ServoRegistry</code> instance in order to unify the collection of REST metrics and the exporting of metrics to the Atlas backend under a single Servo API. Practically, this means that your code may use a mixture of Servo monitors and Spectator meters and both will be scooped up by Spring Boot Actuator <code class="literal">MetricReader</code> instances and both will be shipped to the Atlas backend.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_spectator_counter" href="#_spectator_counter"></a>12.3.1&nbsp;Spectator Counter</h3></div></div></div><p>A counter is used to measure the rate at which some event is occurring.</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// create a counter with a name and a set of tags</span>
Counter counter = registry.counter(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"counterName"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"tagKey1"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"tagValue1"</span>, ...);
counter.increment(); <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// increment when an event occurs</span>
counter.increment(<span class="hl-number">10</span>); <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// increment by a discrete amount</span></pre><p>The counter records a single time-normalized statistic.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_spectator_timer" href="#_spectator_timer"></a>12.3.2&nbsp;Spectator Timer</h3></div></div></div><p>A timer is used to measure how long some event is taking. Spring Cloud automatically records timers for Spring MVC requests and conditionally <code class="literal">RestTemplate</code> requests, which can later be used to create dashboards for request related metrics like latency:</p><div class="figure"><a name="d0e3005" href="#d0e3005"></a><p class="title"><b>Figure&nbsp;12.1.&nbsp;Request Latency</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/RequestLatency.png" alt="RequestLatency"></div></div></div><br class="figure-break"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// create a timer with a name and a set of tags</span>
Timer timer = registry.timer(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"timerName"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"tagKey1"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"tagValue1"</span>, ...);

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// execute an operation and time it at the same time</span>
T result = timer.record(() -&gt; fooReturnsT());

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// alternatively, if you must manually record the time</span>
Long start = System.nanoTime();
T result = fooReturnsT();
timer.record(System.nanoTime() - start, TimeUnit.NANOSECONDS);</pre><p>The timer simultaneously records 4 statistics: count, max, totalOfSquares, and totalTime.  The count statistic will always match the single normalized value provided by a counter if you had called <code class="literal">increment()</code> once on the counter for each time you recorded a timing, so it is rarely necessary to count and time separately for a single operation.</p><p>For <a class="link" href="https://github.com/Netflix/spectator/wiki/Timer-Usage#longtasktimer" target="_top">long running operations</a>, Spectator provides a special <code class="literal">LongTaskTimer</code>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_spectator_gauge" href="#_spectator_gauge"></a>12.3.3&nbsp;Spectator Gauge</h3></div></div></div><p>Gauges are used to determine some current value like the size of a queue or number of threads in a running state. Since gauges are sampled, they provide no information about how these values fluctuate between samples.</p><p>The normal use of a gauge involves registering the gauge once in initialization with an id, a reference to the object to be sampled, and a function to get or compute a numeric value based on the object. The reference to the object is passed in separately and the Spectator registry will keep a weak reference to the object. If the object is garbage collected, then Spectator will automatically drop the registration. See <a class="link" href="https://github.com/Netflix/spectator/wiki/Gauge-Usage#using-lambda" target="_top">the note</a> in Spectator&#8217;s documentation about potential memory leaks if this API is misused.</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// the registry will automatically sample this gauge periodically</span>
registry.gauge(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"gaugeName"</span>, pool, Pool::numberOfRunningThreads);

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// manually sample a value in code at periodic intervals -- last resort!</span>
registry.gauge(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"gaugeName"</span>, Arrays.asList(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"tagKey1"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"tagValue1"</span>, ...), <span class="hl-number">1000</span>);</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_spectator_distribution_summaries" href="#_spectator_distribution_summaries"></a>12.3.4&nbsp;Spectator Distribution Summaries</h3></div></div></div><p>A distribution summary is used to track the distribution of events. It is similar to a timer, but more general in that the size does not have to be a period of time. For example, a distribution summary could be used to measure the payload sizes of requests hitting a server.</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// the registry will automatically sample this gauge periodically</span>
DistributionSummary ds = registry.distributionSummary(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"dsName"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"tagKey1"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"tagValue1"</span>, ...);
ds.record(request.sizeInBytes());</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="netflix-metrics-servo" href="#netflix-metrics-servo"></a>12.4&nbsp;Metrics Collection: Servo</h2></div></div></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="images/warning.png"></td><th align="left">Warning</th></tr><tr><td align="left" valign="top"><p>If your code is compiled on Java 8, please use Spectator instead of Servo as Spectator is destined to replace Servo entirely in the long term.</p></td></tr></table></div><p>In Servo parlance, a monitor is a named, typed, and tagged configuration and a metric represents the value of a given monitor at a point in time. Servo monitors are logically equivalent to Spectator meters. Servo monitors are created and controlled by a <code class="literal">MonitorRegistry</code>. In spite of the above warning, Servo does have a <a class="link" href="https://github.com/Netflix/servo/wiki/Getting-Started" target="_top">wider array</a> of monitor options than Spectator has meters.</p><p>Spring Cloud integration configures an injectable <code class="literal">com.netflix.servo.MonitorRegistry</code> instance for you. Once you have created the appropriate <code class="literal">Monitor</code> type in Servo, the process of recording data is wholly similar to Spectator.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_creating_servo_monitors" href="#_creating_servo_monitors"></a>12.4.1&nbsp;Creating Servo Monitors</h3></div></div></div><p>If you are using the Servo <code class="literal">MonitorRegistry</code> instance provided by Spring Cloud (specifically, an instance of <code class="literal">DefaultMonitorRegistry</code>), Servo provides convenience classes for retrieving <a class="link" href="https://github.com/Netflix/spectator/wiki/Servo-Comparison#dynamiccounter" target="_top">counters</a> and <a class="link" href="https://github.com/Netflix/spectator/wiki/Servo-Comparison#dynamictimer" target="_top">timers</a>.  These convenience classes ensure that only one <code class="literal">Monitor</code> is registered for each unique combination of name and tags.</p><p>To manually create a Monitor type in Servo, especially for the more exotic monitor types for which convenience methods are not provided, instantiate the appropriate type by providing a <code class="literal">MonitorConfig</code> instance:</p><pre class="programlisting">MonitorConfig config = MonitorConfig.builder(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"timerName"</span>).withTag(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"tagKey1"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"tagValue1"</span>).build();

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// somewhere we should cache this Monitor by MonitorConfig</span>
Timer timer = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> BasicTimer(config);
monitorRegistry.register(timer);</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="netflix-metrics-atlas" href="#netflix-metrics-atlas"></a>12.5&nbsp;Metrics Backend: Atlas</h2></div></div></div><p>Atlas was developed by Netflix to manage dimensional time series data for near real-time operational insight. Atlas features in-memory data storage, allowing it to gather and report very large numbers of metrics, very quickly.</p><p>Atlas captures operational intelligence. Whereas business intelligence is data gathered for analyzing trends over time, operational intelligence provides a picture of what is currently happening within a system.</p><p>Spring Cloud provides a <code class="literal">spring-cloud-starter-atlas</code> that has all the dependencies you need. Then just annotate your Spring Boot application with <code class="literal">@EnableAtlas</code> and provide a location for your running Atlas server with the <code class="literal">netflix.atlas.uri</code> property.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_global_tags" href="#_global_tags"></a>12.5.1&nbsp;Global tags</h3></div></div></div><p>Spring Cloud enables you to add tags to every metric sent to the Atlas backend. Global tags can be used to separate metrics by application name, environment, region, etc.</p><p>Each bean implementing <code class="literal">AtlasTagProvider</code> will contribute to the global tag list:</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
AtlasTagProvider atlasCommonTags(
    <em><span class="hl-annotation" style="color: gray">@Value("${spring.application.name}")</span></em> String appName) {
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> () -&gt; Collections.singletonMap(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"app"</span>, appName);
}</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_using_atlas" href="#_using_atlas"></a>12.5.2&nbsp;Using Atlas</h3></div></div></div><p>To bootstrap a in-memory standalone Atlas instance:</p><pre class="programlisting">$ curl -LO https://github.com/Netflix/atlas/releases/download/v1.<span class="hl-number">4.2</span>/atlas-<span class="hl-number">1.4</span>.<span class="hl-number">2</span>-standalone.jar
$ java -jar atlas-<span class="hl-number">1.4</span>.<span class="hl-number">2</span>-standalone.jar</pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>An Atlas standalone node running on an r3.2xlarge (61GB RAM) can handle roughly 2 million metrics per minute for a given 6 hour window.</p></td></tr></table></div><p>Once running and you have collected a handful of metrics, verify that your setup is correct by listing tags on the Atlas server:</p><pre class="programlisting">$ curl http://ATLAS/api/v1/tags</pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>After executing several requests against your service, you can gather some very basic information on the request latency of every request by pasting the following url in your browser: <code class="literal"><a class="link" href="http://ATLAS/api/v1/graph?q=name,rest,:eq,:avg" target="_top">http://ATLAS/api/v1/graph?q=name,rest,:eq,:avg</a></code></p></td></tr></table></div><p>The Atlas wiki contains a <a class="link" href="https://github.com/Netflix/atlas/wiki/Single-Line" target="_top">compilation of sample queries</a> for various scenarios.</p><p>Make sure to check out the <a class="link" href="https://github.com/Netflix/atlas/wiki/Alerting-Philosophy" target="_top">alerting philosophy</a> and docs on using <a class="link" href="https://github.com/Netflix/atlas/wiki/DES" target="_top">double exponential smoothing</a> to generate dynamic alert thresholds.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="retrying-failed-requests" href="#retrying-failed-requests"></a>12.6&nbsp;Retrying Failed Requests</h2></div></div></div><p>Spring Cloud Netflix offers a variety of ways to make HTTP requests.  You can use a load balanced
<code class="literal">RestTemplate</code>, Ribbon, or Feign.  No matter how you choose to your HTTP requests, there is always
a chance the request may fail.  When a request fails you may want to have the request retried
automatically.  To accomplish this when using Sping Cloud Netflix you need to include
<a class="link" href="https://github.com/spring-projects/spring-retry" target="_top">Spring Retry</a> on your application&#8217;s classpath.
When Spring Retry is present load balanced <code class="literal">RestTemplates</code>, Feign, and Zuul will automatically
retry any failed requests (assuming you configuration allows it to).</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_configuration" href="#_configuration"></a>12.6.1&nbsp;Configuration</h3></div></div></div><p>Anytime Ribbon is used with Spring Retry you can control the retry functionality by configuring
certain Ribbon properties.  The properties you can use are
<code class="literal">client.ribbon.MaxAutoRetries</code>, <code class="literal">client.ribbon.MaxAutoRetriesNextServer</code>, and
<code class="literal">client.ribbon.OkToRetryOnAllOperations</code>. See the <a class="link" href="https://github.com/Netflix/ribbon/wiki/Getting-Started#the-properties-file-sample-clientproperties" target="_top">Ribbon documentation</a>
for a description of what there properties do.</p><p>In addition you may want to retry requests when certain status codes are returned in the
response.  You can list the response codes you would like the Ribbon client to retry using the
 property <code class="literal">clientName.ribbon.retryableStatusCodes</code>.  For example</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">clientName</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  ribbon</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    retryableStatusCodes</span>: <span class="hl-number">404</span>,<span class="hl-number">502</span></pre><p>You can also create a bean of type <code class="literal">LoadBalancedRetryPolicy</code> and implement the <code class="literal">retryableStatusCode</code>
method to determine whether you want to retry a request given the status code.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_zuul" href="#_zuul"></a>12.6.2&nbsp;Zuul</h3></div></div></div><p>You can turn off Zuul&#8217;s retry functionality by setting <code class="literal">zuul.retryable</code> to <code class="literal">false</code>.  You
can also disable retry functionality on route by route basis by setting
<code class="literal">zuul.routes.routename.retryable</code> to <code class="literal">false</code>.</p></div></div></div></div></body></html>